# coding: utf-8

"""
    Impinj Reader Configuration REST API

    This API provides an interface for configuring RFID operations and reporting streams on Impinj Readers as well as updating Impinj Reader firmware and configuring system settings.  When retrieved from a reader, this OpenAPI Document is dynamically updated based on the capabilities of the reader. See the '/openapi.json' path.   # noqa: E501

    OpenAPI spec version: 1.7.0
    Contact: developer-feedback@impinj.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def data_stream_get(self, **kwargs):  # noqa: E501
        """Get HTTP stream  # noqa: E501

        Get reader event data as an HTTP stream  **Connecting**  To connect to the reader, form an HTTP request and consume the resulting stream for as long as is practical. The reader will hold the connection open indefinitely, barring reader error, excessive client-side lag, network hiccups, reader maintenance or duplicate logins. In the event there is no new data to stream for an extended period of time, a keep-alive CR-LF character pair will be sent. See /http-stream path.  The method to form an HTTP request and parse the response will be different for every language or framework, so consult the documentation for the HTTP library you are using.  Some HTTP client libraries only return the response body after the connection has been closed by the server. These clients will not work for accessing data via HTTP streaming. You must use an HTTP client that will return response data incrementally. Most robust HTTP client libraries will provide this functionality. The Apache HttpClient will handle this use case, for example.  **Disconnections**  The reader will close a streaming connection for the following reasons:  - A client establishes too many connections with the same credentials. When this occurs, the oldest connection will be terminated.  - A client stops reading data suddenly. If the rate of tag reports being read off of the stream drops suddenly, the connection will be closed.  - A client reads data too slowly. Every streaming connection is backed by a queue of messages to be sent to the client. If this queue grows too large over time, the connection will be closed.  - The reader is rebooted.   **Stalls**   Set a timer, either a 90 second TCP level socket timeout, or a 90 second application level timer on the receipt  of new data. If 90 seconds pass with no data received, including newlines, disconnect and reconnect immediately.  The Streaming API will send a keep-alive periodically to prevent your application from timing out the  connection. You should wait at least 3 cycles to prevent spurious reconnects in the event of network congestion,  local CPU starvation, local GC pauses, etc.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.data_stream_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ReaderEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.data_stream_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.data_stream_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def data_stream_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get HTTP stream  # noqa: E501

        Get reader event data as an HTTP stream  **Connecting**  To connect to the reader, form an HTTP request and consume the resulting stream for as long as is practical. The reader will hold the connection open indefinitely, barring reader error, excessive client-side lag, network hiccups, reader maintenance or duplicate logins. In the event there is no new data to stream for an extended period of time, a keep-alive CR-LF character pair will be sent. See /http-stream path.  The method to form an HTTP request and parse the response will be different for every language or framework, so consult the documentation for the HTTP library you are using.  Some HTTP client libraries only return the response body after the connection has been closed by the server. These clients will not work for accessing data via HTTP streaming. You must use an HTTP client that will return response data incrementally. Most robust HTTP client libraries will provide this functionality. The Apache HttpClient will handle this use case, for example.  **Disconnections**  The reader will close a streaming connection for the following reasons:  - A client establishes too many connections with the same credentials. When this occurs, the oldest connection will be terminated.  - A client stops reading data suddenly. If the rate of tag reports being read off of the stream drops suddenly, the connection will be closed.  - A client reads data too slowly. Every streaming connection is backed by a queue of messages to be sent to the client. If this queue grows too large over time, the connection will be closed.  - The reader is rebooted.   **Stalls**   Set a timer, either a 90 second TCP level socket timeout, or a 90 second application level timer on the receipt  of new data. If 90 seconds pass with no data received, including newlines, disconnect and reconnect immediately.  The Streaming API will send a keep-alive periodically to prevent your application from timing out the  connection. You should wait at least 3 cycles to prevent spurious reconnects in the event of network congestion,  local CPU starvation, local GC pauses, etc.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.data_stream_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ReaderEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method data_stream_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/data/stream', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReaderEvent',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def device_gpos_get(self, **kwargs):  # noqa: E501
        """Retrieve GPO configurations.  # noqa: E501

        Retrieves the GPO configurations of the reader.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.device_gpos_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GpoConfigurations
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.device_gpos_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.device_gpos_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def device_gpos_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve GPO configurations.  # noqa: E501

        Retrieves the GPO configurations of the reader.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.device_gpos_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GpoConfigurations
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method device_gpos_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/device/gpos', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GpoConfigurations',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def device_gpos_put(self, gpo_configurations, **kwargs):  # noqa: E501
        """Update GPO configurations.  # noqa: E501

        Updates the GPO configurations of the reader. If no configuration is provided for a GPO then the existing configuration will be used.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.device_gpos_put(gpo_configurations, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GpoConfigurations gpo_configurations: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.device_gpos_put_with_http_info(gpo_configurations, **kwargs)  # noqa: E501
        else:
            (data) = self.device_gpos_put_with_http_info(gpo_configurations, **kwargs)  # noqa: E501
            return data

    def device_gpos_put_with_http_info(self, gpo_configurations, **kwargs):  # noqa: E501
        """Update GPO configurations.  # noqa: E501

        Updates the GPO configurations of the reader. If no configuration is provided for a GPO then the existing configuration will be used.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.device_gpos_put_with_http_info(gpo_configurations, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GpoConfigurations gpo_configurations: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['gpo_configurations']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method device_gpos_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'gpo_configurations' is set
        if self.api_client.client_side_validation and ('gpo_configurations' not in params or
                                                       params['gpo_configurations'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `gpo_configurations` when calling `device_gpos_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'gpo_configurations' in params:
            body_params = params['gpo_configurations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/device/gpos', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def http_stream_get(self, **kwargs):  # noqa: E501
        """Retrieve HTTP stream settings  # noqa: E501

        Retrieves the configuration settings that apply to all HTTP streams.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.http_stream_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: StreamConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.http_stream_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.http_stream_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def http_stream_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve HTTP stream settings  # noqa: E501

        Retrieves the configuration settings that apply to all HTTP streams.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.http_stream_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: StreamConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method http_stream_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/http-stream', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StreamConfiguration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def http_stream_put(self, updated_stream_configuration, **kwargs):  # noqa: E501
        """Update HTTP stream settings  # noqa: E501

        Updates the HTTP stream settings that apply to all HTTP streams.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.http_stream_put(updated_stream_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param StreamConfiguration updated_stream_configuration: The HTTP stream configuration settings (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.http_stream_put_with_http_info(updated_stream_configuration, **kwargs)  # noqa: E501
        else:
            (data) = self.http_stream_put_with_http_info(updated_stream_configuration, **kwargs)  # noqa: E501
            return data

    def http_stream_put_with_http_info(self, updated_stream_configuration, **kwargs):  # noqa: E501
        """Update HTTP stream settings  # noqa: E501

        Updates the HTTP stream settings that apply to all HTTP streams.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.http_stream_put_with_http_info(updated_stream_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param StreamConfiguration updated_stream_configuration: The HTTP stream configuration settings (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['updated_stream_configuration']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method http_stream_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'updated_stream_configuration' is set
        if self.api_client.client_side_validation and ('updated_stream_configuration' not in params or
                                                       params['updated_stream_configuration'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `updated_stream_configuration` when calling `http_stream_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'updated_stream_configuration' in params:
            body_params = params['updated_stream_configuration']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/http-stream', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def kafka_get(self, **kwargs):  # noqa: E501
        """Retrieve Kafka settings  # noqa: E501

        Retrieves the current Kafka configuration settings for pushing messages to a Kafka broker.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.kafka_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: KafkaConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.kafka_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.kafka_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def kafka_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve Kafka settings  # noqa: E501

        Retrieves the current Kafka configuration settings for pushing messages to a Kafka broker.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.kafka_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: KafkaConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method kafka_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/kafka', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='KafkaConfiguration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def kafka_put(self, updated_kafka_configuration, **kwargs):  # noqa: E501
        """Update Kafka settings  # noqa: E501

        Updates the Kafka settings used by the device.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.kafka_put(updated_kafka_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param KafkaConfiguration updated_kafka_configuration: The fully defined Kafka configuration settings the device should use when pushing messages to a Kafka broker. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.kafka_put_with_http_info(updated_kafka_configuration, **kwargs)  # noqa: E501
        else:
            (data) = self.kafka_put_with_http_info(updated_kafka_configuration, **kwargs)  # noqa: E501
            return data

    def kafka_put_with_http_info(self, updated_kafka_configuration, **kwargs):  # noqa: E501
        """Update Kafka settings  # noqa: E501

        Updates the Kafka settings used by the device.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.kafka_put_with_http_info(updated_kafka_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param KafkaConfiguration updated_kafka_configuration: The fully defined Kafka configuration settings the device should use when pushing messages to a Kafka broker. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['updated_kafka_configuration']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method kafka_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'updated_kafka_configuration' is set
        if self.api_client.client_side_validation and ('updated_kafka_configuration' not in params or
                                                       params['updated_kafka_configuration'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `updated_kafka_configuration` when calling `kafka_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'updated_kafka_configuration' in params:
            body_params = params['updated_kafka_configuration']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/kafka', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mqtt_get(self, **kwargs):  # noqa: E501
        """Retrieve MQTT settings  # noqa: E501

        Retrieves the current MQTT configuration settings for publishing data to an MQTT broker.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mqtt_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: MqttConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mqtt_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.mqtt_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def mqtt_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve MQTT settings  # noqa: E501

        Retrieves the current MQTT configuration settings for publishing data to an MQTT broker.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mqtt_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: MqttConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mqtt_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/mqtt', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MqttConfiguration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mqtt_put(self, updated_mqtt_configuration, **kwargs):  # noqa: E501
        """Update MQTT settings  # noqa: E501

        Updates the MQTT settings used by the device.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mqtt_put(updated_mqtt_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MqttConfiguration updated_mqtt_configuration: The fully defined MQTT configuration settings the device should use when publishing data to an MQTT broker. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mqtt_put_with_http_info(updated_mqtt_configuration, **kwargs)  # noqa: E501
        else:
            (data) = self.mqtt_put_with_http_info(updated_mqtt_configuration, **kwargs)  # noqa: E501
            return data

    def mqtt_put_with_http_info(self, updated_mqtt_configuration, **kwargs):  # noqa: E501
        """Update MQTT settings  # noqa: E501

        Updates the MQTT settings used by the device.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mqtt_put_with_http_info(updated_mqtt_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MqttConfiguration updated_mqtt_configuration: The fully defined MQTT configuration settings the device should use when publishing data to an MQTT broker. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['updated_mqtt_configuration']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mqtt_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'updated_mqtt_configuration' is set
        if self.api_client.client_side_validation and ('updated_mqtt_configuration' not in params or
                                                       params['updated_mqtt_configuration'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `updated_mqtt_configuration` when calling `mqtt_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'updated_mqtt_configuration' in params:
            body_params = params['updated_mqtt_configuration']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/mqtt', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def openapi_json_get(self, **kwargs):  # noqa: E501
        """Get OpenAPI Document  # noqa: E501

        Retrieve the OpenAPI Document for this Reader. The document describes the API using reader-specific capabilities and constraints, such as region-specific transmit power limits and supported RF Modes. It also includes definitions and paths associated with all registered profiles. If the IoT Interface is disabled, this will only contain system endpoints.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.openapi_json_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.openapi_json_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.openapi_json_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def openapi_json_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get OpenAPI Document  # noqa: E501

        Retrieve the OpenAPI Document for this Reader. The document describes the API using reader-specific capabilities and constraints, such as region-specific transmit power limits and supported RF Modes. It also includes definitions and paths associated with all registered profiles. If the IoT Interface is disabled, this will only contain system endpoints.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.openapi_json_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method openapi_json_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/openapi.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def profiles_get(self, **kwargs):  # noqa: E501
        """Retrieve profiles  # noqa: E501

        Retrieves the profiles (e.g. inventory, location, and direction) supported by this reader.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profiles_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.profiles_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.profiles_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def profiles_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve profiles  # noqa: E501

        Retrieves the profiles (e.g. inventory, location, and direction) supported by this reader.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profiles_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method profiles_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/profiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def profiles_inventory_presets_get(self, **kwargs):  # noqa: E501
        """Retrieve inventory presets  # noqa: E501

        Retrieves the available presets for running inventory.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profiles_inventory_presets_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PresetId]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.profiles_inventory_presets_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.profiles_inventory_presets_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def profiles_inventory_presets_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve inventory presets  # noqa: E501

        Retrieves the available presets for running inventory.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profiles_inventory_presets_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PresetId]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method profiles_inventory_presets_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/profiles/inventory/presets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PresetId]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def profiles_inventory_presets_preset_id_delete(self, preset_id, **kwargs):  # noqa: E501
        """Delete inventory preset  # noqa: E501

        Removes a user-defined settings preset for executing inventory.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profiles_inventory_presets_preset_id_delete(preset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str preset_id: The name of a preset. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.profiles_inventory_presets_preset_id_delete_with_http_info(preset_id, **kwargs)  # noqa: E501
        else:
            (data) = self.profiles_inventory_presets_preset_id_delete_with_http_info(preset_id, **kwargs)  # noqa: E501
            return data

    def profiles_inventory_presets_preset_id_delete_with_http_info(self, preset_id, **kwargs):  # noqa: E501
        """Delete inventory preset  # noqa: E501

        Removes a user-defined settings preset for executing inventory.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profiles_inventory_presets_preset_id_delete_with_http_info(preset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str preset_id: The name of a preset. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['preset_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method profiles_inventory_presets_preset_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'preset_id' is set
        if self.api_client.client_side_validation and ('preset_id' not in params or
                                                       params['preset_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `preset_id` when calling `profiles_inventory_presets_preset_id_delete`")  # noqa: E501

        if self.api_client.client_side_validation and ('preset_id' in params and
                                                       len(params['preset_id']) > 128):
            raise ValueError("Invalid value for parameter `preset_id` when calling `profiles_inventory_presets_preset_id_delete`, length must be less than or equal to `128`")  # noqa: E501
        if self.api_client.client_side_validation and ('preset_id' in params and not re.search(r'^[a-zA-Z0-9_.-]+$', params['preset_id'])):  # noqa: E501
            raise ValueError("Invalid value for parameter `preset_id` when calling `profiles_inventory_presets_preset_id_delete`, must conform to the pattern `/^[a-zA-Z0-9_.-]+$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'preset_id' in params:
            path_params['presetId'] = params['preset_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/profiles/inventory/presets/{presetId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def profiles_inventory_presets_preset_id_get(self, preset_id, **kwargs):  # noqa: E501
        """Retrieve inventory preset detail  # noqa: E501

        Retrieves the detailed configuration of the specified preset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profiles_inventory_presets_preset_id_get(preset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str preset_id: The name of a preset. (required)
        :return: InventoryRequest
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.profiles_inventory_presets_preset_id_get_with_http_info(preset_id, **kwargs)  # noqa: E501
        else:
            (data) = self.profiles_inventory_presets_preset_id_get_with_http_info(preset_id, **kwargs)  # noqa: E501
            return data

    def profiles_inventory_presets_preset_id_get_with_http_info(self, preset_id, **kwargs):  # noqa: E501
        """Retrieve inventory preset detail  # noqa: E501

        Retrieves the detailed configuration of the specified preset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profiles_inventory_presets_preset_id_get_with_http_info(preset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str preset_id: The name of a preset. (required)
        :return: InventoryRequest
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['preset_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method profiles_inventory_presets_preset_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'preset_id' is set
        if self.api_client.client_side_validation and ('preset_id' not in params or
                                                       params['preset_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `preset_id` when calling `profiles_inventory_presets_preset_id_get`")  # noqa: E501

        if self.api_client.client_side_validation and ('preset_id' in params and
                                                       len(params['preset_id']) > 128):
            raise ValueError("Invalid value for parameter `preset_id` when calling `profiles_inventory_presets_preset_id_get`, length must be less than or equal to `128`")  # noqa: E501
        if self.api_client.client_side_validation and ('preset_id' in params and not re.search(r'^[a-zA-Z0-9_.-]+$', params['preset_id'])):  # noqa: E501
            raise ValueError("Invalid value for parameter `preset_id` when calling `profiles_inventory_presets_preset_id_get`, must conform to the pattern `/^[a-zA-Z0-9_.-]+$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'preset_id' in params:
            path_params['presetId'] = params['preset_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/profiles/inventory/presets/{presetId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InventoryRequest',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def profiles_inventory_presets_preset_id_put(self, preset_id, preset_object, **kwargs):  # noqa: E501
        """Create or replace inventory preset  # noqa: E501

        Creates or replaces a user-defined inventory preset.  Presets with names that begin with 'default' or 'impinj' may not be created or replaced.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profiles_inventory_presets_preset_id_put(preset_id, preset_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str preset_id: The name of a preset. (required)
        :param InventoryRequest preset_object: inventory profile configuration (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.profiles_inventory_presets_preset_id_put_with_http_info(preset_id, preset_object, **kwargs)  # noqa: E501
        else:
            (data) = self.profiles_inventory_presets_preset_id_put_with_http_info(preset_id, preset_object, **kwargs)  # noqa: E501
            return data

    def profiles_inventory_presets_preset_id_put_with_http_info(self, preset_id, preset_object, **kwargs):  # noqa: E501
        """Create or replace inventory preset  # noqa: E501

        Creates or replaces a user-defined inventory preset.  Presets with names that begin with 'default' or 'impinj' may not be created or replaced.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profiles_inventory_presets_preset_id_put_with_http_info(preset_id, preset_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str preset_id: The name of a preset. (required)
        :param InventoryRequest preset_object: inventory profile configuration (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['preset_id', 'preset_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method profiles_inventory_presets_preset_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'preset_id' is set
        if self.api_client.client_side_validation and ('preset_id' not in params or
                                                       params['preset_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `preset_id` when calling `profiles_inventory_presets_preset_id_put`")  # noqa: E501
        # verify the required parameter 'preset_object' is set
        if self.api_client.client_side_validation and ('preset_object' not in params or
                                                       params['preset_object'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `preset_object` when calling `profiles_inventory_presets_preset_id_put`")  # noqa: E501

        if self.api_client.client_side_validation and ('preset_id' in params and
                                                       len(params['preset_id']) > 128):
            raise ValueError("Invalid value for parameter `preset_id` when calling `profiles_inventory_presets_preset_id_put`, length must be less than or equal to `128`")  # noqa: E501
        if self.api_client.client_side_validation and ('preset_id' in params and not re.search(r'^(?!default|impinj)[a-zA-Z0-9_.-]+$', params['preset_id'])):  # noqa: E501
            raise ValueError("Invalid value for parameter `preset_id` when calling `profiles_inventory_presets_preset_id_put`, must conform to the pattern `/^(?!default|impinj)[a-zA-Z0-9_.-]+$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'preset_id' in params:
            path_params['presetId'] = params['preset_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'preset_object' in params:
            body_params = params['preset_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/profiles/inventory/presets/{presetId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def profiles_inventory_presets_preset_id_start_post(self, preset_id, **kwargs):  # noqa: E501
        """Start inventory preset  # noqa: E501

        Starts running the specified inventory preset. The running preset cannot be replaced or deleted. The preset will be automatically restarted if the reader reboots. If the reader is restarted multiple times in quick succcession the saved preset may be stopped to prevent the bad preset from blocking access to the rest interface. If this occurs an ERROR level message will be logged.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profiles_inventory_presets_preset_id_start_post(preset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str preset_id: The name of a preset. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.profiles_inventory_presets_preset_id_start_post_with_http_info(preset_id, **kwargs)  # noqa: E501
        else:
            (data) = self.profiles_inventory_presets_preset_id_start_post_with_http_info(preset_id, **kwargs)  # noqa: E501
            return data

    def profiles_inventory_presets_preset_id_start_post_with_http_info(self, preset_id, **kwargs):  # noqa: E501
        """Start inventory preset  # noqa: E501

        Starts running the specified inventory preset. The running preset cannot be replaced or deleted. The preset will be automatically restarted if the reader reboots. If the reader is restarted multiple times in quick succcession the saved preset may be stopped to prevent the bad preset from blocking access to the rest interface. If this occurs an ERROR level message will be logged.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profiles_inventory_presets_preset_id_start_post_with_http_info(preset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str preset_id: The name of a preset. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['preset_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method profiles_inventory_presets_preset_id_start_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'preset_id' is set
        if self.api_client.client_side_validation and ('preset_id' not in params or
                                                       params['preset_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `preset_id` when calling `profiles_inventory_presets_preset_id_start_post`")  # noqa: E501

        if self.api_client.client_side_validation and ('preset_id' in params and
                                                       len(params['preset_id']) > 128):
            raise ValueError("Invalid value for parameter `preset_id` when calling `profiles_inventory_presets_preset_id_start_post`, length must be less than or equal to `128`")  # noqa: E501
        if self.api_client.client_side_validation and ('preset_id' in params and not re.search(r'^[a-zA-Z0-9_.-]+$', params['preset_id'])):  # noqa: E501
            raise ValueError("Invalid value for parameter `preset_id` when calling `profiles_inventory_presets_preset_id_start_post`, must conform to the pattern `/^[a-zA-Z0-9_.-]+$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'preset_id' in params:
            path_params['presetId'] = params['preset_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/profiles/inventory/presets/{presetId}/start', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def profiles_inventory_presets_schema_get(self, **kwargs):  # noqa: E501
        """Retrieve inventory schema  # noqa: E501

        Deprecated: This path will be removed in a future release. The device-specific schema and capabilities can be observed via the \"/openapi.json\" API path instead.  Retrieves the reader-specific JSON schema used to validate inventory presets. This is a good way to determine reader capabilities such as max transmit power or available RF modes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profiles_inventory_presets_schema_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: PresetsSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.profiles_inventory_presets_schema_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.profiles_inventory_presets_schema_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def profiles_inventory_presets_schema_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve inventory schema  # noqa: E501

        Deprecated: This path will be removed in a future release. The device-specific schema and capabilities can be observed via the \"/openapi.json\" API path instead.  Retrieves the reader-specific JSON schema used to validate inventory presets. This is a good way to determine reader capabilities such as max transmit power or available RF modes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profiles_inventory_presets_schema_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: PresetsSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method profiles_inventory_presets_schema_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/profiles/inventory/presets-schema', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PresetsSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def profiles_inventory_start_post(self, preset_object, **kwargs):  # noqa: E501
        """Start transient inventory preset  # noqa: E501

        Start running inventory using the provided inventory configuration. The configuration is not saved and not restarted if the reader reboots.  Transient presets are recommended for running configuration that is updated frequently or for which there is no benefit to storing the configuration on the reader after the preset has stopped. Transient presets are usually the best choice when performing operations that modify tag memory or are meant to operate on a specific tag.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profiles_inventory_start_post(preset_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param InventoryRequest preset_object: inventory profile configuration (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.profiles_inventory_start_post_with_http_info(preset_object, **kwargs)  # noqa: E501
        else:
            (data) = self.profiles_inventory_start_post_with_http_info(preset_object, **kwargs)  # noqa: E501
            return data

    def profiles_inventory_start_post_with_http_info(self, preset_object, **kwargs):  # noqa: E501
        """Start transient inventory preset  # noqa: E501

        Start running inventory using the provided inventory configuration. The configuration is not saved and not restarted if the reader reboots.  Transient presets are recommended for running configuration that is updated frequently or for which there is no benefit to storing the configuration on the reader after the preset has stopped. Transient presets are usually the best choice when performing operations that modify tag memory or are meant to operate on a specific tag.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profiles_inventory_start_post_with_http_info(preset_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param InventoryRequest preset_object: inventory profile configuration (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['preset_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method profiles_inventory_start_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'preset_object' is set
        if self.api_client.client_side_validation and ('preset_object' not in params or
                                                       params['preset_object'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `preset_object` when calling `profiles_inventory_start_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'preset_object' in params:
            body_params = params['preset_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/profiles/inventory/start', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def profiles_inventory_tag_get(self, **kwargs):  # noqa: E501
        """Checks for the presence of a tag in the field of view of an antenna.  # noqa: E501

        Returns information on whether the specified tag was seen on the specified antenna in the tag reporting interval. Available only if TagReportingConfiguration feature is enabled. Must specify exactly one tag identifier and one antenna identifier.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profiles_inventory_tag_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str epc: The base64url-encoded EPC of the tag of interest.
        :param str epc_hex: The hex-encoded EPC of the tag of interest.
        :param str tid: The base64url-encoded TID of the tag of interest.
        :param str tid_hex: The hex-encoded TID of the tag of interest.
        :param int antenna_port: The port number of the antenna for the tag of interest.
        :param str antenna_name: Name for the antenna for the tag of interest.
        :return: TagPresenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.profiles_inventory_tag_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.profiles_inventory_tag_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def profiles_inventory_tag_get_with_http_info(self, **kwargs):  # noqa: E501
        """Checks for the presence of a tag in the field of view of an antenna.  # noqa: E501

        Returns information on whether the specified tag was seen on the specified antenna in the tag reporting interval. Available only if TagReportingConfiguration feature is enabled. Must specify exactly one tag identifier and one antenna identifier.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profiles_inventory_tag_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str epc: The base64url-encoded EPC of the tag of interest.
        :param str epc_hex: The hex-encoded EPC of the tag of interest.
        :param str tid: The base64url-encoded TID of the tag of interest.
        :param str tid_hex: The hex-encoded TID of the tag of interest.
        :param int antenna_port: The port number of the antenna for the tag of interest.
        :param str antenna_name: Name for the antenna for the tag of interest.
        :return: TagPresenceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['epc', 'epc_hex', 'tid', 'tid_hex', 'antenna_port', 'antenna_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method profiles_inventory_tag_get" % key
                )
            params[key] = val
        del params['kwargs']

        if self.api_client.client_side_validation and ('epc_hex' in params and not re.search(r'^[0-9A-F]+$', params['epc_hex'])):  # noqa: E501
            raise ValueError("Invalid value for parameter `epc_hex` when calling `profiles_inventory_tag_get`, must conform to the pattern `/^[0-9A-F]+$/`")  # noqa: E501
        if self.api_client.client_side_validation and ('tid_hex' in params and not re.search(r'^[0-9A-F]+$', params['tid_hex'])):  # noqa: E501
            raise ValueError("Invalid value for parameter `tid_hex` when calling `profiles_inventory_tag_get`, must conform to the pattern `/^[0-9A-F]+$/`")  # noqa: E501
        if self.api_client.client_side_validation and ('antenna_port' in params and params['antenna_port'] < 1):  # noqa: E501
            raise ValueError("Invalid value for parameter `antenna_port` when calling `profiles_inventory_tag_get`, must be a value greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and ('antenna_name' in params and
                                                       len(params['antenna_name']) > 64):
            raise ValueError("Invalid value for parameter `antenna_name` when calling `profiles_inventory_tag_get`, length must be less than or equal to `64`")  # noqa: E501
        if self.api_client.client_side_validation and ('antenna_name' in params and not re.search(r'^[a-zA-Z0-9_.-]+$', params['antenna_name'])):  # noqa: E501
            raise ValueError("Invalid value for parameter `antenna_name` when calling `profiles_inventory_tag_get`, must conform to the pattern `/^[a-zA-Z0-9_.-]+$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'epc' in params:
            query_params.append(('epc', params['epc']))  # noqa: E501
        if 'epc_hex' in params:
            query_params.append(('epcHex', params['epc_hex']))  # noqa: E501
        if 'tid' in params:
            query_params.append(('tid', params['tid']))  # noqa: E501
        if 'tid_hex' in params:
            query_params.append(('tidHex', params['tid_hex']))  # noqa: E501
        if 'antenna_port' in params:
            query_params.append(('antennaPort', params['antenna_port']))  # noqa: E501
        if 'antenna_name' in params:
            query_params.append(('antennaName', params['antenna_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/profiles/inventory/tag', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TagPresenceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def profiles_stop_post(self, **kwargs):  # noqa: E501
        """Stop preset  # noqa: E501

        Stops the currently running profile preset. If no preset is currently running, this is a no-op.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profiles_stop_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.profiles_stop_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.profiles_stop_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def profiles_stop_post_with_http_info(self, **kwargs):  # noqa: E501
        """Stop preset  # noqa: E501

        Stops the currently running profile preset. If no preset is currently running, this is a no-op.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profiles_stop_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method profiles_stop_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/profiles/stop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def status_get(self, **kwargs):  # noqa: E501
        """Retrieve status  # noqa: E501

        Retrieves the reader's current status. This endpoint allow's a user to query what the reader is actively working on, if anything. The information contained here will indicate the last request the reader responded to that resulted in it taking some modem action, such as starting or stopping inventory. Configuration API calls are not included.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.status_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ReaderStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.status_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.status_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def status_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve status  # noqa: E501

        Retrieves the reader's current status. This endpoint allow's a user to query what the reader is actively working on, if anything. The information contained here will indicate the last request the reader responded to that resulted in it taking some modem action, such as starting or stopping inventory. Configuration API calls are not included.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.status_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ReaderStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method status_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReaderStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_access_authentication_get(self, **kwargs):  # noqa: E501
        """Retrieve the reader's authentication configuration.  # noqa: E501

        Retrieves the reader's authentication configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_access_authentication_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AuthenticationConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_access_authentication_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_access_authentication_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_access_authentication_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve the reader's authentication configuration.  # noqa: E501

        Retrieves the reader's authentication configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_access_authentication_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AuthenticationConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_access_authentication_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/access/authentication', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AuthenticationConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_access_authentication_put(self, auth_config, **kwargs):  # noqa: E501
        """Update the reader's authentication configuration.  # noqa: E501

        Updates the reader's authentication configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_access_authentication_put(auth_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AuthenticationConfig auth_config: The authentication configuration to update. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_access_authentication_put_with_http_info(auth_config, **kwargs)  # noqa: E501
        else:
            (data) = self.system_access_authentication_put_with_http_info(auth_config, **kwargs)  # noqa: E501
            return data

    def system_access_authentication_put_with_http_info(self, auth_config, **kwargs):  # noqa: E501
        """Update the reader's authentication configuration.  # noqa: E501

        Updates the reader's authentication configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_access_authentication_put_with_http_info(auth_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AuthenticationConfig auth_config: The authentication configuration to update. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['auth_config']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_access_authentication_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'auth_config' is set
        if self.api_client.client_side_validation and ('auth_config' not in params or
                                                       params['auth_config'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `auth_config` when calling `system_access_authentication_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'auth_config' in params:
            body_params = params['auth_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/access/authentication', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_access_users_get(self, **kwargs):  # noqa: E501
        """Retrieve the list of users.  # noqa: E501

        Retrieves the list of users that can access reader.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_access_users_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[UserInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_access_users_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_access_users_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_access_users_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve the list of users.  # noqa: E501

        Retrieves the list of users that can access reader.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_access_users_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[UserInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_access_users_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/access/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[UserInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_access_users_user_id_password_put(self, user_id, password_info, **kwargs):  # noqa: E501
        """Update the password for the specified user.  # noqa: E501

        Updates the password for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_access_users_user_id_password_put(user_id, password_info, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int user_id: The unique identifier for a user. (required)
        :param PasswordInfo password_info: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_access_users_user_id_password_put_with_http_info(user_id, password_info, **kwargs)  # noqa: E501
        else:
            (data) = self.system_access_users_user_id_password_put_with_http_info(user_id, password_info, **kwargs)  # noqa: E501
            return data

    def system_access_users_user_id_password_put_with_http_info(self, user_id, password_info, **kwargs):  # noqa: E501
        """Update the password for the specified user.  # noqa: E501

        Updates the password for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_access_users_user_id_password_put_with_http_info(user_id, password_info, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int user_id: The unique identifier for a user. (required)
        :param PasswordInfo password_info: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'password_info']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_access_users_user_id_password_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `system_access_users_user_id_password_put`")  # noqa: E501
        # verify the required parameter 'password_info' is set
        if self.api_client.client_side_validation and ('password_info' not in params or
                                                       params['password_info'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `password_info` when calling `system_access_users_user_id_password_put`")  # noqa: E501

        if self.api_client.client_side_validation and ('user_id' in params and params['user_id'] < 0):  # noqa: E501
            raise ValueError("Invalid value for parameter `user_id` when calling `system_access_users_user_id_password_put`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'password_info' in params:
            body_params = params['password_info']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/access/users/{userId}/password', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_antenna_hub_disable_post(self, **kwargs):  # noqa: E501
        """Disable the antenna-hub feature.  # noqa: E501

        Disable the antenna-hub feature. System reboot is required for the new configuration to take effect.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_antenna_hub_disable_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: StatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_antenna_hub_disable_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_antenna_hub_disable_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_antenna_hub_disable_post_with_http_info(self, **kwargs):  # noqa: E501
        """Disable the antenna-hub feature.  # noqa: E501

        Disable the antenna-hub feature. System reboot is required for the new configuration to take effect.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_antenna_hub_disable_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: StatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_antenna_hub_disable_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/antenna-hub/disable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_antenna_hub_enable_post(self, **kwargs):  # noqa: E501
        """Enable the antenna-hub feature.  # noqa: E501

        Enable the antenna-hub feature. System reboot is required for the new configuration to take effect.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_antenna_hub_enable_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: StatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_antenna_hub_enable_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_antenna_hub_enable_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_antenna_hub_enable_post_with_http_info(self, **kwargs):  # noqa: E501
        """Enable the antenna-hub feature.  # noqa: E501

        Enable the antenna-hub feature. System reboot is required for the new configuration to take effect.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_antenna_hub_enable_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: StatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_antenna_hub_enable_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/antenna-hub/enable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_antenna_hub_get(self, **kwargs):  # noqa: E501
        """Retrieve antenna-hub information.  # noqa: E501

        Retrieve the current antenna-hub status, including a list of connected hubs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_antenna_hub_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool pending: If set to true, the response will reflect the future antenna-hub state after the next reboot. This will differ from the current state when a request to enable or disable the antenna-hub feature has been made. 
        :return: AntennaHubInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_antenna_hub_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_antenna_hub_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_antenna_hub_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve antenna-hub information.  # noqa: E501

        Retrieve the current antenna-hub status, including a list of connected hubs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_antenna_hub_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool pending: If set to true, the response will reflect the future antenna-hub state after the next reboot. This will differ from the current state when a request to enable or disable the antenna-hub feature has been made. 
        :return: AntennaHubInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pending']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_antenna_hub_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pending' in params:
            query_params.append(('pending', params['pending']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/antenna-hub', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AntennaHubInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_cap_installation_get(self, **kwargs):  # noqa: E501
        """Retrieve the current installation configuration settings.  # noqa: E501

        Retrieve the current Customer Application (CAP) installation configuration settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_cap_installation_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CapInstallationConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_cap_installation_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_cap_installation_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_cap_installation_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve the current installation configuration settings.  # noqa: E501

        Retrieve the current Customer Application (CAP) installation configuration settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_cap_installation_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CapInstallationConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_cap_installation_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/cap/installation', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CapInstallationConfiguration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_cap_installation_put(self, installation_configuration, **kwargs):  # noqa: E501
        """Update CAP installation configuration settings.  # noqa: E501

        Updates CAP installation configuration settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_cap_installation_put(installation_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CapInstallationConfiguration installation_configuration: The new CAP installation configuration settings. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_cap_installation_put_with_http_info(installation_configuration, **kwargs)  # noqa: E501
        else:
            (data) = self.system_cap_installation_put_with_http_info(installation_configuration, **kwargs)  # noqa: E501
            return data

    def system_cap_installation_put_with_http_info(self, installation_configuration, **kwargs):  # noqa: E501
        """Update CAP installation configuration settings.  # noqa: E501

        Updates CAP installation configuration settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_cap_installation_put_with_http_info(installation_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CapInstallationConfiguration installation_configuration: The new CAP installation configuration settings. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['installation_configuration']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_cap_installation_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'installation_configuration' is set
        if self.api_client.client_side_validation and ('installation_configuration' not in params or
                                                       params['installation_configuration'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `installation_configuration` when calling `system_cap_installation_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'installation_configuration' in params:
            body_params = params['installation_configuration']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/cap/installation', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_certificates_ca_certs_cert_id_delete(self, cert_id, **kwargs):  # noqa: E501
        """Remove CA certificate.  # noqa: E501

        Removes the specified CA certificate from the reader.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_ca_certs_cert_id_delete(cert_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int cert_id: The unique identifier assigned to the certificate by the reader. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_certificates_ca_certs_cert_id_delete_with_http_info(cert_id, **kwargs)  # noqa: E501
        else:
            (data) = self.system_certificates_ca_certs_cert_id_delete_with_http_info(cert_id, **kwargs)  # noqa: E501
            return data

    def system_certificates_ca_certs_cert_id_delete_with_http_info(self, cert_id, **kwargs):  # noqa: E501
        """Remove CA certificate.  # noqa: E501

        Removes the specified CA certificate from the reader.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_ca_certs_cert_id_delete_with_http_info(cert_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int cert_id: The unique identifier assigned to the certificate by the reader. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cert_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_certificates_ca_certs_cert_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cert_id' is set
        if self.api_client.client_side_validation and ('cert_id' not in params or
                                                       params['cert_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `cert_id` when calling `system_certificates_ca_certs_cert_id_delete`")  # noqa: E501

        if self.api_client.client_side_validation and ('cert_id' in params and params['cert_id'] < 1):  # noqa: E501
            raise ValueError("Invalid value for parameter `cert_id` when calling `system_certificates_ca_certs_cert_id_delete`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'cert_id' in params:
            path_params['certId'] = params['cert_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/certificates/ca/certs/{certId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_certificates_ca_certs_cert_id_get(self, cert_id, **kwargs):  # noqa: E501
        """Retrieve CA certificate.  # noqa: E501

        Retrieves certficate information for the specified CA certificate.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_ca_certs_cert_id_get(cert_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int cert_id: The unique identifier assigned to the certificate by the reader. (required)
        :return: CertificateInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_certificates_ca_certs_cert_id_get_with_http_info(cert_id, **kwargs)  # noqa: E501
        else:
            (data) = self.system_certificates_ca_certs_cert_id_get_with_http_info(cert_id, **kwargs)  # noqa: E501
            return data

    def system_certificates_ca_certs_cert_id_get_with_http_info(self, cert_id, **kwargs):  # noqa: E501
        """Retrieve CA certificate.  # noqa: E501

        Retrieves certficate information for the specified CA certificate.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_ca_certs_cert_id_get_with_http_info(cert_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int cert_id: The unique identifier assigned to the certificate by the reader. (required)
        :return: CertificateInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cert_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_certificates_ca_certs_cert_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cert_id' is set
        if self.api_client.client_side_validation and ('cert_id' not in params or
                                                       params['cert_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `cert_id` when calling `system_certificates_ca_certs_cert_id_get`")  # noqa: E501

        if self.api_client.client_side_validation and ('cert_id' in params and params['cert_id'] < 1):  # noqa: E501
            raise ValueError("Invalid value for parameter `cert_id` when calling `system_certificates_ca_certs_cert_id_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'cert_id' in params:
            path_params['certId'] = params['cert_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/certificates/ca/certs/{certId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CertificateInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_certificates_ca_certs_get(self, **kwargs):  # noqa: E501
        """Retrieve CA certificates.  # noqa: E501

        Retrieves user-installed CA certificates on the reader which includes Root and intermediate CA certificates.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_ca_certs_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[CertificateInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_certificates_ca_certs_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_certificates_ca_certs_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_certificates_ca_certs_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve CA certificates.  # noqa: E501

        Retrieves user-installed CA certificates on the reader which includes Root and intermediate CA certificates.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_ca_certs_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[CertificateInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_certificates_ca_certs_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/certificates/ca/certs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CertificateInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_certificates_ca_certs_post(self, cert_file, **kwargs):  # noqa: E501
        """Install CA certificates.  # noqa: E501

        Installs CA certificates on the reader. Only PEM format is supported. It is possible to install a certificate bundle which contains multiple certificates. The certificates will be automatically validated prior to installing on the reader.  The certificate ID assigned to each certificate will be returned in the response upon successful installation.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_ca_certs_post(cert_file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file cert_file: The certificate file to be installed on the reader. (required)
        :return: list[CertificateId]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_certificates_ca_certs_post_with_http_info(cert_file, **kwargs)  # noqa: E501
        else:
            (data) = self.system_certificates_ca_certs_post_with_http_info(cert_file, **kwargs)  # noqa: E501
            return data

    def system_certificates_ca_certs_post_with_http_info(self, cert_file, **kwargs):  # noqa: E501
        """Install CA certificates.  # noqa: E501

        Installs CA certificates on the reader. Only PEM format is supported. It is possible to install a certificate bundle which contains multiple certificates. The certificates will be automatically validated prior to installing on the reader.  The certificate ID assigned to each certificate will be returned in the response upon successful installation.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_ca_certs_post_with_http_info(cert_file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file cert_file: The certificate file to be installed on the reader. (required)
        :return: list[CertificateId]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cert_file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_certificates_ca_certs_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cert_file' is set
        if self.api_client.client_side_validation and ('cert_file' not in params or
                                                       params['cert_file'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `cert_file` when calling `system_certificates_ca_certs_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'cert_file' in params:
            local_var_files['certFile'] = params['cert_file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/certificates/ca/certs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CertificateId]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_certificates_cap_certs_cert_id_delete(self, cert_id, **kwargs):  # noqa: E501
        """Remove CAP authentication certificate.  # noqa: E501

        Removes the specified CAP authentication certificate from the reader.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_cap_certs_cert_id_delete(cert_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int cert_id: The unique identifier assigned to the certificate by the reader. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_certificates_cap_certs_cert_id_delete_with_http_info(cert_id, **kwargs)  # noqa: E501
        else:
            (data) = self.system_certificates_cap_certs_cert_id_delete_with_http_info(cert_id, **kwargs)  # noqa: E501
            return data

    def system_certificates_cap_certs_cert_id_delete_with_http_info(self, cert_id, **kwargs):  # noqa: E501
        """Remove CAP authentication certificate.  # noqa: E501

        Removes the specified CAP authentication certificate from the reader.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_cap_certs_cert_id_delete_with_http_info(cert_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int cert_id: The unique identifier assigned to the certificate by the reader. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cert_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_certificates_cap_certs_cert_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cert_id' is set
        if self.api_client.client_side_validation and ('cert_id' not in params or
                                                       params['cert_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `cert_id` when calling `system_certificates_cap_certs_cert_id_delete`")  # noqa: E501

        if self.api_client.client_side_validation and ('cert_id' in params and params['cert_id'] < 1):  # noqa: E501
            raise ValueError("Invalid value for parameter `cert_id` when calling `system_certificates_cap_certs_cert_id_delete`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'cert_id' in params:
            path_params['certId'] = params['cert_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/certificates/cap/certs/{certId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_certificates_cap_certs_cert_id_get(self, cert_id, **kwargs):  # noqa: E501
        """Retrieve a CAP authentication certificate.  # noqa: E501

        Retrieves certificate information for the specified CAP authentication certificate.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_cap_certs_cert_id_get(cert_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int cert_id: The unique identifier assigned to the certificate by the reader. (required)
        :return: CertificateInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_certificates_cap_certs_cert_id_get_with_http_info(cert_id, **kwargs)  # noqa: E501
        else:
            (data) = self.system_certificates_cap_certs_cert_id_get_with_http_info(cert_id, **kwargs)  # noqa: E501
            return data

    def system_certificates_cap_certs_cert_id_get_with_http_info(self, cert_id, **kwargs):  # noqa: E501
        """Retrieve a CAP authentication certificate.  # noqa: E501

        Retrieves certificate information for the specified CAP authentication certificate.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_cap_certs_cert_id_get_with_http_info(cert_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int cert_id: The unique identifier assigned to the certificate by the reader. (required)
        :return: CertificateInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cert_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_certificates_cap_certs_cert_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cert_id' is set
        if self.api_client.client_side_validation and ('cert_id' not in params or
                                                       params['cert_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `cert_id` when calling `system_certificates_cap_certs_cert_id_get`")  # noqa: E501

        if self.api_client.client_side_validation and ('cert_id' in params and params['cert_id'] < 1):  # noqa: E501
            raise ValueError("Invalid value for parameter `cert_id` when calling `system_certificates_cap_certs_cert_id_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'cert_id' in params:
            path_params['certId'] = params['cert_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/certificates/cap/certs/{certId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CertificateInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_certificates_cap_certs_get(self, **kwargs):  # noqa: E501
        """Retrieve CAP authentication certificates.  # noqa: E501

        Retrieves all installed CAP authentication certificates on the reader. This may include the default certificate, if it has not been removed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_cap_certs_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[CertificateInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_certificates_cap_certs_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_certificates_cap_certs_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_certificates_cap_certs_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve CAP authentication certificates.  # noqa: E501

        Retrieves all installed CAP authentication certificates on the reader. This may include the default certificate, if it has not been removed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_cap_certs_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[CertificateInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_certificates_cap_certs_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/certificates/cap/certs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CertificateInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_certificates_cap_certs_post(self, cert_file, **kwargs):  # noqa: E501
        """Install CAP authentication certificates.  # noqa: E501

        Installs a single CAP authentication certificate on the reader. Only PEM format is supported. The certificate will be validated prior to installing on the reader.  On success, an array containing a single certificate ID will be returned in the response.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_cap_certs_post(cert_file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file cert_file: The CAP authentication certificate file to be installed on the reader. (required)
        :return: list[CertificateId]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_certificates_cap_certs_post_with_http_info(cert_file, **kwargs)  # noqa: E501
        else:
            (data) = self.system_certificates_cap_certs_post_with_http_info(cert_file, **kwargs)  # noqa: E501
            return data

    def system_certificates_cap_certs_post_with_http_info(self, cert_file, **kwargs):  # noqa: E501
        """Install CAP authentication certificates.  # noqa: E501

        Installs a single CAP authentication certificate on the reader. Only PEM format is supported. The certificate will be validated prior to installing on the reader.  On success, an array containing a single certificate ID will be returned in the response.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_cap_certs_post_with_http_info(cert_file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file cert_file: The CAP authentication certificate file to be installed on the reader. (required)
        :return: list[CertificateId]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cert_file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_certificates_cap_certs_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cert_file' is set
        if self.api_client.client_side_validation and ('cert_file' not in params or
                                                       params['cert_file'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `cert_file` when calling `system_certificates_cap_certs_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'cert_file' in params:
            local_var_files['certFile'] = params['cert_file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/certificates/cap/certs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CertificateId]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_certificates_tls_certs_cert_id_delete(self, cert_id, **kwargs):  # noqa: E501
        """Remove TLS certificate.  # noqa: E501

        Removes the specified certificate from the reader. The private key associated with the certificate will be automatically removed as well.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_tls_certs_cert_id_delete(cert_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int cert_id: The unique identifier assigned to the certificate by the reader. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_certificates_tls_certs_cert_id_delete_with_http_info(cert_id, **kwargs)  # noqa: E501
        else:
            (data) = self.system_certificates_tls_certs_cert_id_delete_with_http_info(cert_id, **kwargs)  # noqa: E501
            return data

    def system_certificates_tls_certs_cert_id_delete_with_http_info(self, cert_id, **kwargs):  # noqa: E501
        """Remove TLS certificate.  # noqa: E501

        Removes the specified certificate from the reader. The private key associated with the certificate will be automatically removed as well.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_tls_certs_cert_id_delete_with_http_info(cert_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int cert_id: The unique identifier assigned to the certificate by the reader. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cert_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_certificates_tls_certs_cert_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cert_id' is set
        if self.api_client.client_side_validation and ('cert_id' not in params or
                                                       params['cert_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `cert_id` when calling `system_certificates_tls_certs_cert_id_delete`")  # noqa: E501

        if self.api_client.client_side_validation and ('cert_id' in params and params['cert_id'] < 1):  # noqa: E501
            raise ValueError("Invalid value for parameter `cert_id` when calling `system_certificates_tls_certs_cert_id_delete`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'cert_id' in params:
            path_params['certId'] = params['cert_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/certificates/tls/certs/{certId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_certificates_tls_certs_cert_id_get(self, cert_id, **kwargs):  # noqa: E501
        """Retrieve TLS certficate.  # noqa: E501

        Retrieves TLS certficate information for the specified certificate.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_tls_certs_cert_id_get(cert_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int cert_id: The unique identifier assigned to the certificate by the reader. (required)
        :return: CertificateInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_certificates_tls_certs_cert_id_get_with_http_info(cert_id, **kwargs)  # noqa: E501
        else:
            (data) = self.system_certificates_tls_certs_cert_id_get_with_http_info(cert_id, **kwargs)  # noqa: E501
            return data

    def system_certificates_tls_certs_cert_id_get_with_http_info(self, cert_id, **kwargs):  # noqa: E501
        """Retrieve TLS certficate.  # noqa: E501

        Retrieves TLS certficate information for the specified certificate.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_tls_certs_cert_id_get_with_http_info(cert_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int cert_id: The unique identifier assigned to the certificate by the reader. (required)
        :return: CertificateInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cert_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_certificates_tls_certs_cert_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cert_id' is set
        if self.api_client.client_side_validation and ('cert_id' not in params or
                                                       params['cert_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `cert_id` when calling `system_certificates_tls_certs_cert_id_get`")  # noqa: E501

        if self.api_client.client_side_validation and ('cert_id' in params and params['cert_id'] < 1):  # noqa: E501
            raise ValueError("Invalid value for parameter `cert_id` when calling `system_certificates_tls_certs_cert_id_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'cert_id' in params:
            path_params['certId'] = params['cert_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/certificates/tls/certs/{certId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CertificateInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_certificates_tls_certs_get(self, **kwargs):  # noqa: E501
        """Retrieve TLS certificates.  # noqa: E501

        Retrieves user-installed TLS certificates on the reader which includes server and client certificates.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_tls_certs_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[CertificateInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_certificates_tls_certs_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_certificates_tls_certs_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_certificates_tls_certs_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve TLS certificates.  # noqa: E501

        Retrieves user-installed TLS certificates on the reader which includes server and client certificates.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_tls_certs_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[CertificateInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_certificates_tls_certs_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/certificates/tls/certs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CertificateInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_certificates_tls_certs_post(self, cert_file, **kwargs):  # noqa: E501
        """Install TLS certificate.  # noqa: E501

        Installs TLS certificate on the reader using either pkcs12 or PEM format.  When installing a certificate using pkcs12 format, the password used to encrypt the bundle must be included in the request.  The certificate ID will be returned in the response upon successful installation.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_tls_certs_post(cert_file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file cert_file: The certificate file to be installed on the reader. (required)
        :param str password: The password that was used to create the pkcs12 bundle.
        :return: CertificateId
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_certificates_tls_certs_post_with_http_info(cert_file, **kwargs)  # noqa: E501
        else:
            (data) = self.system_certificates_tls_certs_post_with_http_info(cert_file, **kwargs)  # noqa: E501
            return data

    def system_certificates_tls_certs_post_with_http_info(self, cert_file, **kwargs):  # noqa: E501
        """Install TLS certificate.  # noqa: E501

        Installs TLS certificate on the reader using either pkcs12 or PEM format.  When installing a certificate using pkcs12 format, the password used to encrypt the bundle must be included in the request.  The certificate ID will be returned in the response upon successful installation.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_tls_certs_post_with_http_info(cert_file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file cert_file: The certificate file to be installed on the reader. (required)
        :param str password: The password that was used to create the pkcs12 bundle.
        :return: CertificateId
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cert_file', 'password']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_certificates_tls_certs_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cert_file' is set
        if self.api_client.client_side_validation and ('cert_file' not in params or
                                                       params['cert_file'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `cert_file` when calling `system_certificates_tls_certs_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'cert_file' in params:
            local_var_files['certFile'] = params['cert_file']  # noqa: E501
        if 'password' in params:
            form_params.append(('password', params['password']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/certificates/tls/certs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CertificateId',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_certificates_tls_csr_post(self, csr_configuration, **kwargs):  # noqa: E501
        """Create a certificate signing request(CSR).  # noqa: E501

        Create a CSR file that could be sent to a Certificate Authority(CA) for certificate issuance.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_tls_csr_post(csr_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CsrConfiguration csr_configuration: The configuration settings to be included in the CSR. (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_certificates_tls_csr_post_with_http_info(csr_configuration, **kwargs)  # noqa: E501
        else:
            (data) = self.system_certificates_tls_csr_post_with_http_info(csr_configuration, **kwargs)  # noqa: E501
            return data

    def system_certificates_tls_csr_post_with_http_info(self, csr_configuration, **kwargs):  # noqa: E501
        """Create a certificate signing request(CSR).  # noqa: E501

        Create a CSR file that could be sent to a Certificate Authority(CA) for certificate issuance.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_tls_csr_post_with_http_info(csr_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CsrConfiguration csr_configuration: The configuration settings to be included in the CSR. (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['csr_configuration']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_certificates_tls_csr_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'csr_configuration' is set
        if self.api_client.client_side_validation and ('csr_configuration' not in params or
                                                       params['csr_configuration'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `csr_configuration` when calling `system_certificates_tls_csr_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'csr_configuration' in params:
            body_params = params['csr_configuration']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/certificates/tls/csr', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_certificates_tls_services_tls_service_get(self, tls_service, **kwargs):  # noqa: E501
        """Retrieve certificate info for the specified service.  # noqa: E501

        Retrieves the certificate info for the specified service. If the specified service has not been configured to use a user-installed certificate, a 204 response will be returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_tls_services_tls_service_get(tls_service, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tls_service: Available services on the reader that use TLS certificates. (required)
        :return: CertificateInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_certificates_tls_services_tls_service_get_with_http_info(tls_service, **kwargs)  # noqa: E501
        else:
            (data) = self.system_certificates_tls_services_tls_service_get_with_http_info(tls_service, **kwargs)  # noqa: E501
            return data

    def system_certificates_tls_services_tls_service_get_with_http_info(self, tls_service, **kwargs):  # noqa: E501
        """Retrieve certificate info for the specified service.  # noqa: E501

        Retrieves the certificate info for the specified service. If the specified service has not been configured to use a user-installed certificate, a 204 response will be returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_tls_services_tls_service_get_with_http_info(tls_service, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tls_service: Available services on the reader that use TLS certificates. (required)
        :return: CertificateInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tls_service']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_certificates_tls_services_tls_service_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tls_service' is set
        if self.api_client.client_side_validation and ('tls_service' not in params or
                                                       params['tls_service'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `tls_service` when calling `system_certificates_tls_services_tls_service_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tls_service' in params:
            path_params['tlsService'] = params['tls_service']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/certificates/tls/services/{tlsService}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CertificateInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_certificates_tls_services_tls_service_put(self, tls_service, cert_config, **kwargs):  # noqa: E501
        """Update certificate info for the specified service.  # noqa: E501

        Updates certificate info for the specified service to use one of the available certificates installed on the reader.  The extended key usage on the certificate must match the intended usage of the service.  For example: If the extended key usage on the certificate only have `server authentication` bit set, then the certificate can not be used for 'client authentication' (e.g `mqtt-client`).  If the extended key usage on the certificate have both `server authentication` and 'client authentication' bits set, then the certificate could be used for both `https-server` and `mqtt-client`.  If the extended key usage on the certificate is not specified, then the certificate could be used for any purpose that the reader supports.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_tls_services_tls_service_put(tls_service, cert_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tls_service: Available services on the reader that use TLS certificates. (required)
        :param CertificateConfig cert_config: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_certificates_tls_services_tls_service_put_with_http_info(tls_service, cert_config, **kwargs)  # noqa: E501
        else:
            (data) = self.system_certificates_tls_services_tls_service_put_with_http_info(tls_service, cert_config, **kwargs)  # noqa: E501
            return data

    def system_certificates_tls_services_tls_service_put_with_http_info(self, tls_service, cert_config, **kwargs):  # noqa: E501
        """Update certificate info for the specified service.  # noqa: E501

        Updates certificate info for the specified service to use one of the available certificates installed on the reader.  The extended key usage on the certificate must match the intended usage of the service.  For example: If the extended key usage on the certificate only have `server authentication` bit set, then the certificate can not be used for 'client authentication' (e.g `mqtt-client`).  If the extended key usage on the certificate have both `server authentication` and 'client authentication' bits set, then the certificate could be used for both `https-server` and `mqtt-client`.  If the extended key usage on the certificate is not specified, then the certificate could be used for any purpose that the reader supports.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_certificates_tls_services_tls_service_put_with_http_info(tls_service, cert_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tls_service: Available services on the reader that use TLS certificates. (required)
        :param CertificateConfig cert_config: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tls_service', 'cert_config']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_certificates_tls_services_tls_service_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tls_service' is set
        if self.api_client.client_side_validation and ('tls_service' not in params or
                                                       params['tls_service'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `tls_service` when calling `system_certificates_tls_services_tls_service_put`")  # noqa: E501
        # verify the required parameter 'cert_config' is set
        if self.api_client.client_side_validation and ('cert_config' not in params or
                                                       params['cert_config'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `cert_config` when calling `system_certificates_tls_services_tls_service_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tls_service' in params:
            path_params['tlsService'] = params['tls_service']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cert_config' in params:
            body_params = params['cert_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/certificates/tls/services/{tlsService}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_diagnostics_debug_bundle_get(self, **kwargs):  # noqa: E501
        """Generate and retrieve a diagnostic bundle.  # noqa: E501

        Generates and retrieves a diagnostic bundle containing current diagnostic information.  The bundle contains - An index.html file containing information about the bundle, including the time it was   generated and the directory structure. - The syslog logs - The journal logs - Core files - The RDD buffer - OS release information - A startup graph - Other reader configuration information This bundle is not stored on the reader.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_diagnostics_debug_bundle_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_diagnostics_debug_bundle_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_diagnostics_debug_bundle_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_diagnostics_debug_bundle_get_with_http_info(self, **kwargs):  # noqa: E501
        """Generate and retrieve a diagnostic bundle.  # noqa: E501

        Generates and retrieves a diagnostic bundle containing current diagnostic information.  The bundle contains - An index.html file containing information about the bundle, including the time it was   generated and the directory structure. - The syslog logs - The journal logs - Core files - The RDD buffer - OS release information - A startup graph - Other reader configuration information This bundle is not stored on the reader.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_diagnostics_debug_bundle_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_diagnostics_debug_bundle_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/gzip'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/diagnostics/debug-bundle', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_diagnostics_watchdog_bundle_delete(self, **kwargs):  # noqa: E501
        """Delete core files and diagnostic bundle generated by a watchdog reboot.  # noqa: E501

        Deletes all core files on the reader and the diagnostic bundle generated by a watchdog reboot, if one exists.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_diagnostics_watchdog_bundle_delete(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_diagnostics_watchdog_bundle_delete_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_diagnostics_watchdog_bundle_delete_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_diagnostics_watchdog_bundle_delete_with_http_info(self, **kwargs):  # noqa: E501
        """Delete core files and diagnostic bundle generated by a watchdog reboot.  # noqa: E501

        Deletes all core files on the reader and the diagnostic bundle generated by a watchdog reboot, if one exists.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_diagnostics_watchdog_bundle_delete_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_diagnostics_watchdog_bundle_delete" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/diagnostics/watchdog-bundle', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_diagnostics_watchdog_bundle_get(self, **kwargs):  # noqa: E501
        """Retrieve diagnostic bundle generated by a watchdog reboot.  # noqa: E501

        Retrieves an existing diagnostic bundle generated before the most recent watchdog reboot, if one exists. When a watchdog reboot occurs, a bundle is generated from the logs and other reader state information before the reboot. At most one such bundle can be stored on the reader at a time. If another watchdog reboot occurs when there is already a bundle stored on the reader, the oldest will be overwritten. The information contained in this bundle is a snapshot of the reader state immediately before the most recent watchdog reboot.  The bundle contains - An index.html file containing information about the bundle, including the time it was   generated and its directory structure. - The syslog logs - The journal logs - Core files - The RDD buffer - OS release information - A startup graph - Other reader configuration and state information   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_diagnostics_watchdog_bundle_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_diagnostics_watchdog_bundle_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_diagnostics_watchdog_bundle_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_diagnostics_watchdog_bundle_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve diagnostic bundle generated by a watchdog reboot.  # noqa: E501

        Retrieves an existing diagnostic bundle generated before the most recent watchdog reboot, if one exists. When a watchdog reboot occurs, a bundle is generated from the logs and other reader state information before the reboot. At most one such bundle can be stored on the reader at a time. If another watchdog reboot occurs when there is already a bundle stored on the reader, the oldest will be overwritten. The information contained in this bundle is a snapshot of the reader state immediately before the most recent watchdog reboot.  The bundle contains - An index.html file containing information about the bundle, including the time it was   generated and its directory structure. - The syslog logs - The journal logs - Core files - The RDD buffer - OS release information - A startup graph - Other reader configuration and state information   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_diagnostics_watchdog_bundle_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_diagnostics_watchdog_bundle_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/gzip'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/diagnostics/watchdog-bundle', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_get(self, **kwargs):  # noqa: E501
        """Retrieve details about the reader hardware.  # noqa: E501

        Retrieve details about the reader hardware.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SystemInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve details about the reader hardware.  # noqa: E501

        Retrieve details about the reader hardware.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SystemInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SystemInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_hostname_get(self, **kwargs):  # noqa: E501
        """Retrieve the reader hostname.  # noqa: E501

        Retrieves the current hostname of the reader. Note that this is not a fully qualified domain name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_hostname_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Hostname
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_hostname_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_hostname_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_hostname_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve the reader hostname.  # noqa: E501

        Retrieves the current hostname of the reader. Note that this is not a fully qualified domain name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_hostname_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Hostname
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_hostname_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/hostname', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Hostname',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_hostname_put(self, hostname, **kwargs):  # noqa: E501
        """Update the reader hostname.  # noqa: E501

        Updates the reader hostname to the specified value.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_hostname_put(hostname, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Hostname hostname: The new hostname to be set for the reader. The hostname must conform with RFC-952 and RFC-1123.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_hostname_put_with_http_info(hostname, **kwargs)  # noqa: E501
        else:
            (data) = self.system_hostname_put_with_http_info(hostname, **kwargs)  # noqa: E501
            return data

    def system_hostname_put_with_http_info(self, hostname, **kwargs):  # noqa: E501
        """Update the reader hostname.  # noqa: E501

        Updates the reader hostname to the specified value.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_hostname_put_with_http_info(hostname, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Hostname hostname: The new hostname to be set for the reader. The hostname must conform with RFC-952 and RFC-1123.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hostname']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_hostname_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hostname' is set
        if self.api_client.client_side_validation and ('hostname' not in params or
                                                       params['hostname'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `hostname` when calling `system_hostname_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'hostname' in params:
            body_params = params['hostname']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/hostname', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_http_get(self, **kwargs):  # noqa: E501
        """Retrieve the current HTTP server configuration settings.  # noqa: E501

        Retrieves the current HTTP server configuration settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_http_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: HttpConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_http_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_http_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_http_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve the current HTTP server configuration settings.  # noqa: E501

        Retrieves the current HTTP server configuration settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_http_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: HttpConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_http_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/http', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HttpConfiguration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_http_put(self, http_configuration, **kwargs):  # noqa: E501
        """Update HTTP server configuration settings.  # noqa: E501

        Updates HTTP server configuration settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_http_put(http_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param HttpConfiguration http_configuration: The new HTTP configuration settings. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_http_put_with_http_info(http_configuration, **kwargs)  # noqa: E501
        else:
            (data) = self.system_http_put_with_http_info(http_configuration, **kwargs)  # noqa: E501
            return data

    def system_http_put_with_http_info(self, http_configuration, **kwargs):  # noqa: E501
        """Update HTTP server configuration settings.  # noqa: E501

        Updates HTTP server configuration settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_http_put_with_http_info(http_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param HttpConfiguration http_configuration: The new HTTP configuration settings. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['http_configuration']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_http_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'http_configuration' is set
        if self.api_client.client_side_validation and ('http_configuration' not in params or
                                                       params['http_configuration'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `http_configuration` when calling `system_http_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'http_configuration' in params:
            body_params = params['http_configuration']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/http', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_https_get(self, **kwargs):  # noqa: E501
        """Retrieve the current HTTPS server configuration settings.  # noqa: E501

        Retrieves the current HTTPS server configuration settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_https_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: HttpsConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_https_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_https_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_https_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve the current HTTPS server configuration settings.  # noqa: E501

        Retrieves the current HTTPS server configuration settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_https_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: HttpsConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_https_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/https', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HttpsConfiguration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_https_put(self, https_configuration, **kwargs):  # noqa: E501
        """Update HTTPS server configuration settings.  # noqa: E501

        Updates HTTPS server configuration settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_https_put(https_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param HttpsConfiguration https_configuration: The new HTTPS configuration settings. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_https_put_with_http_info(https_configuration, **kwargs)  # noqa: E501
        else:
            (data) = self.system_https_put_with_http_info(https_configuration, **kwargs)  # noqa: E501
            return data

    def system_https_put_with_http_info(self, https_configuration, **kwargs):  # noqa: E501
        """Update HTTPS server configuration settings.  # noqa: E501

        Updates HTTPS server configuration settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_https_put_with_http_info(https_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param HttpsConfiguration https_configuration: The new HTTPS configuration settings. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['https_configuration']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_https_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'https_configuration' is set
        if self.api_client.client_side_validation and ('https_configuration' not in params or
                                                       params['https_configuration'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `https_configuration` when calling `system_https_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'https_configuration' in params:
            body_params = params['https_configuration']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/https', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_image_get(self, **kwargs):  # noqa: E501
        """Retrieve details about the reader's firmware.  # noqa: E501

        A successful `GET` request to this endpoint will return detailed information about the firmware installed on the reader. Properties are omitted for uninstalled or unavailable partitions.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_image_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SystemImage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_image_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_image_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_image_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve details about the reader's firmware.  # noqa: E501

        A successful `GET` request to this endpoint will return detailed information about the firmware installed on the reader. Properties are omitted for uninstalled or unavailable partitions.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_image_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SystemImage
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_image_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/image', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SystemImage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_image_upgrade_get(self, **kwargs):  # noqa: E501
        """Get details about the state of a firmware upgrade.  # noqa: E501

        The state of any upgrades occurring on the reader can be monitored from this endpoint.  Note that once an upgrade has reached the `successful` state, it will take effect the next time the reader is booted. The user must trigger the reboot as the reader won't reboot on its own.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_image_upgrade_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: UpgradeStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_image_upgrade_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_image_upgrade_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_image_upgrade_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get details about the state of a firmware upgrade.  # noqa: E501

        The state of any upgrades occurring on the reader can be monitored from this endpoint.  Note that once an upgrade has reached the `successful` state, it will take effect the next time the reader is booted. The user must trigger the reboot as the reader won't reboot on its own.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_image_upgrade_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: UpgradeStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_image_upgrade_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/image/upgrade', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UpgradeStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_image_upgrade_post(self, upgrade_file, **kwargs):  # noqa: E501
        """Upload an upgrade file for installation.  # noqa: E501

        In order to perform an upgrade, the upgrade file must be uploaded to the reader using this endpoint. Upon successfully uploading an upgrade file to the reader, the reader will acknowledge receipt of the upgrade file by issuing a `202: Accepted` response.  Following such a response, the client can visit the status URL for the current state of the upgrade operation.  Once an upgrade file has completed transfer with this endpoint, subsequent requests will receive a response of `409: Conflict` until one of the following conditions is met:  - The upgrade was successfully installed, and the reader is awaiting reboot. - The upgrade failed to install.  If an upgrade has been installed, but the reader has not yet been rebooted, a different upgrade file can be installed over the previous upgrade.  Any successfully installed upgrade will take effect the next time the reader is booted.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_image_upgrade_post(upgrade_file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file upgrade_file: The upgrade file to be installed on the reader. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_image_upgrade_post_with_http_info(upgrade_file, **kwargs)  # noqa: E501
        else:
            (data) = self.system_image_upgrade_post_with_http_info(upgrade_file, **kwargs)  # noqa: E501
            return data

    def system_image_upgrade_post_with_http_info(self, upgrade_file, **kwargs):  # noqa: E501
        """Upload an upgrade file for installation.  # noqa: E501

        In order to perform an upgrade, the upgrade file must be uploaded to the reader using this endpoint. Upon successfully uploading an upgrade file to the reader, the reader will acknowledge receipt of the upgrade file by issuing a `202: Accepted` response.  Following such a response, the client can visit the status URL for the current state of the upgrade operation.  Once an upgrade file has completed transfer with this endpoint, subsequent requests will receive a response of `409: Conflict` until one of the following conditions is met:  - The upgrade was successfully installed, and the reader is awaiting reboot. - The upgrade failed to install.  If an upgrade has been installed, but the reader has not yet been rebooted, a different upgrade file can be installed over the previous upgrade.  Any successfully installed upgrade will take effect the next time the reader is booted.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_image_upgrade_post_with_http_info(upgrade_file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file upgrade_file: The upgrade file to be installed on the reader. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['upgrade_file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_image_upgrade_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'upgrade_file' is set
        if self.api_client.client_side_validation and ('upgrade_file' not in params or
                                                       params['upgrade_file'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `upgrade_file` when calling `system_image_upgrade_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'upgrade_file' in params:
            local_var_files['upgradeFile'] = params['upgrade_file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/image/upgrade', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_mdns_get(self, **kwargs):  # noqa: E501
        """Retrieve the current mDNS configuration settings.  # noqa: E501

        Retrieve the current mDNS configuration settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_mdns_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: MdnsConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_mdns_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_mdns_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_mdns_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve the current mDNS configuration settings.  # noqa: E501

        Retrieve the current mDNS configuration settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_mdns_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: MdnsConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_mdns_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/mdns', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MdnsConfiguration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_mdns_put(self, mdns_configuration, **kwargs):  # noqa: E501
        """Update mDNS configuration settings.  # noqa: E501

        Updates mDNS configuration settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_mdns_put(mdns_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MdnsConfiguration mdns_configuration: The new mDNS configuration settings. (required)
        :return: StatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_mdns_put_with_http_info(mdns_configuration, **kwargs)  # noqa: E501
        else:
            (data) = self.system_mdns_put_with_http_info(mdns_configuration, **kwargs)  # noqa: E501
            return data

    def system_mdns_put_with_http_info(self, mdns_configuration, **kwargs):  # noqa: E501
        """Update mDNS configuration settings.  # noqa: E501

        Updates mDNS configuration settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_mdns_put_with_http_info(mdns_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MdnsConfiguration mdns_configuration: The new mDNS configuration settings. (required)
        :return: StatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mdns_configuration']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_mdns_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mdns_configuration' is set
        if self.api_client.client_side_validation and ('mdns_configuration' not in params or
                                                       params['mdns_configuration'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `mdns_configuration` when calling `system_mdns_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'mdns_configuration' in params:
            body_params = params['mdns_configuration']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/mdns', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_network_dns_domains_get(self, **kwargs):  # noqa: E501
        """Retrieve the search domains.  # noqa: E501

        Retrieves both static and dynamic search domains that are being used by the DNS resolver on the reader. Dynamic search domains are configured automatically via a DHCP server and static search domains are those configured manually.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_dns_domains_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SearchDomains
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_network_dns_domains_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_network_dns_domains_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_network_dns_domains_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve the search domains.  # noqa: E501

        Retrieves both static and dynamic search domains that are being used by the DNS resolver on the reader. Dynamic search domains are configured automatically via a DHCP server and static search domains are those configured manually.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_dns_domains_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SearchDomains
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_network_dns_domains_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/network/dns/domains', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchDomains',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_network_dns_domains_put(self, search_domains, **kwargs):  # noqa: E501
        """Update static search domains used by the reader.  # noqa: E501

        Updates the static search domains used by the reader. Up to 12 static search domains are allowed. It is possible to convert the dynamic search domains to static search domains by including them on the list to update. An empty list of search domains would indicate that no static search domains should be used and all previously configured search domains should be removed from the reader.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_dns_domains_put(search_domains, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SearchDomains search_domains: A list of static search domains to update. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_network_dns_domains_put_with_http_info(search_domains, **kwargs)  # noqa: E501
        else:
            (data) = self.system_network_dns_domains_put_with_http_info(search_domains, **kwargs)  # noqa: E501
            return data

    def system_network_dns_domains_put_with_http_info(self, search_domains, **kwargs):  # noqa: E501
        """Update static search domains used by the reader.  # noqa: E501

        Updates the static search domains used by the reader. Up to 12 static search domains are allowed. It is possible to convert the dynamic search domains to static search domains by including them on the list to update. An empty list of search domains would indicate that no static search domains should be used and all previously configured search domains should be removed from the reader.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_dns_domains_put_with_http_info(search_domains, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SearchDomains search_domains: A list of static search domains to update. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_domains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_network_dns_domains_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_domains' is set
        if self.api_client.client_side_validation and ('search_domains' not in params or
                                                       params['search_domains'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `search_domains` when calling `system_network_dns_domains_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'search_domains' in params:
            body_params = params['search_domains']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/network/dns/domains', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_network_dns_servers_get(self, **kwargs):  # noqa: E501
        """Retrieve the DNS servers from the reader.  # noqa: E501

        Retrieves both static and dynamic DNS servers that are being used by the DNS resolver on the reader. Dynamic DNS servers are obtained automatically via a DHCP server and static DNS servers are those configured manually by users.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_dns_servers_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: DnsServers
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_network_dns_servers_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_network_dns_servers_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_network_dns_servers_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve the DNS servers from the reader.  # noqa: E501

        Retrieves both static and dynamic DNS servers that are being used by the DNS resolver on the reader. Dynamic DNS servers are obtained automatically via a DHCP server and static DNS servers are those configured manually by users.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_dns_servers_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: DnsServers
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_network_dns_servers_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/network/dns/servers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DnsServers',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_network_dns_servers_put(self, dns_servers, **kwargs):  # noqa: E501
        """Update the static DNS servers used by the reader.  # noqa: E501

        Updates the static DNS servers used by the reader. Up to 12 static DNS servers are allowed. It is possible to convert dynamic DNS servers to static DNS servers by including them on the list to update. An empty list of DNS servers would indicate that no static DNS server should be used and all previously configured DNS servers should be removed from the reader.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_dns_servers_put(dns_servers, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DnsServers dns_servers: A list of static DNS servers to update. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_network_dns_servers_put_with_http_info(dns_servers, **kwargs)  # noqa: E501
        else:
            (data) = self.system_network_dns_servers_put_with_http_info(dns_servers, **kwargs)  # noqa: E501
            return data

    def system_network_dns_servers_put_with_http_info(self, dns_servers, **kwargs):  # noqa: E501
        """Update the static DNS servers used by the reader.  # noqa: E501

        Updates the static DNS servers used by the reader. Up to 12 static DNS servers are allowed. It is possible to convert dynamic DNS servers to static DNS servers by including them on the list to update. An empty list of DNS servers would indicate that no static DNS server should be used and all previously configured DNS servers should be removed from the reader.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_dns_servers_put_with_http_info(dns_servers, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DnsServers dns_servers: A list of static DNS servers to update. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dns_servers']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_network_dns_servers_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dns_servers' is set
        if self.api_client.client_side_validation and ('dns_servers' not in params or
                                                       params['dns_servers'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `dns_servers` when calling `system_network_dns_servers_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dns_servers' in params:
            body_params = params['dns_servers']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/network/dns/servers', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_network_interfaces_get(self, **kwargs):  # noqa: E501
        """Retrieve the current network information for all interfaces.  # noqa: E501

        Retrieves the available network interfaces and their current network information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_interfaces_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[NetworkInterface]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_network_interfaces_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_network_interfaces_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_network_interfaces_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve the current network information for all interfaces.  # noqa: E501

        Retrieves the available network interfaces and their current network information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_interfaces_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[NetworkInterface]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_network_interfaces_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/network/interfaces', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NetworkInterface]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_network_interfaces_interface_id_get(self, interface_id, **kwargs):  # noqa: E501
        """Retrieve the specified network interface state.  # noqa: E501

        Retrieves the specified network interface state.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_interfaces_interface_id_get(interface_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int interface_id: The unique identifier of the network interface assigned by the reader. (required)
        :param bool pending:
        :return: NetworkInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_network_interfaces_interface_id_get_with_http_info(interface_id, **kwargs)  # noqa: E501
        else:
            (data) = self.system_network_interfaces_interface_id_get_with_http_info(interface_id, **kwargs)  # noqa: E501
            return data

    def system_network_interfaces_interface_id_get_with_http_info(self, interface_id, **kwargs):  # noqa: E501
        """Retrieve the specified network interface state.  # noqa: E501

        Retrieves the specified network interface state.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_interfaces_interface_id_get_with_http_info(interface_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int interface_id: The unique identifier of the network interface assigned by the reader. (required)
        :param bool pending:
        :return: NetworkInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['interface_id', 'pending']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_network_interfaces_interface_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'interface_id' is set
        if self.api_client.client_side_validation and ('interface_id' not in params or
                                                       params['interface_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `interface_id` when calling `system_network_interfaces_interface_id_get`")  # noqa: E501

        if self.api_client.client_side_validation and ('interface_id' in params and params['interface_id'] > 32):  # noqa: E501
            raise ValueError("Invalid value for parameter `interface_id` when calling `system_network_interfaces_interface_id_get`, must be a value less than or equal to `32`")  # noqa: E501
        if self.api_client.client_side_validation and ('interface_id' in params and params['interface_id'] < 0):  # noqa: E501
            raise ValueError("Invalid value for parameter `interface_id` when calling `system_network_interfaces_interface_id_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'interface_id' in params:
            path_params['interfaceId'] = params['interface_id']  # noqa: E501

        query_params = []
        if 'pending' in params:
            query_params.append(('pending', params['pending']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/network/interfaces/{interfaceId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetworkInterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_network_interfaces_interface_id_network_protocol_configuration_get(self, interface_id, network_protocol, **kwargs):  # noqa: E501
        """Retrieve the current configuration of a network interface.  # noqa: E501

        Retrieves the current IPv4 or IPv6 configuration of the specified interface. The `networkProtocol` parameter indicates a specific Network Protocol version of the configuration to retrieve.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_interfaces_interface_id_network_protocol_configuration_get(interface_id, network_protocol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int interface_id: The unique identifier of the network interface assigned by the reader. (required)
        :param str network_protocol: The network protocol version of the configuration. (required)
        :return: IpConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_network_interfaces_interface_id_network_protocol_configuration_get_with_http_info(interface_id, network_protocol, **kwargs)  # noqa: E501
        else:
            (data) = self.system_network_interfaces_interface_id_network_protocol_configuration_get_with_http_info(interface_id, network_protocol, **kwargs)  # noqa: E501
            return data

    def system_network_interfaces_interface_id_network_protocol_configuration_get_with_http_info(self, interface_id, network_protocol, **kwargs):  # noqa: E501
        """Retrieve the current configuration of a network interface.  # noqa: E501

        Retrieves the current IPv4 or IPv6 configuration of the specified interface. The `networkProtocol` parameter indicates a specific Network Protocol version of the configuration to retrieve.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_interfaces_interface_id_network_protocol_configuration_get_with_http_info(interface_id, network_protocol, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int interface_id: The unique identifier of the network interface assigned by the reader. (required)
        :param str network_protocol: The network protocol version of the configuration. (required)
        :return: IpConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['interface_id', 'network_protocol']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_network_interfaces_interface_id_network_protocol_configuration_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'interface_id' is set
        if self.api_client.client_side_validation and ('interface_id' not in params or
                                                       params['interface_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `interface_id` when calling `system_network_interfaces_interface_id_network_protocol_configuration_get`")  # noqa: E501
        # verify the required parameter 'network_protocol' is set
        if self.api_client.client_side_validation and ('network_protocol' not in params or
                                                       params['network_protocol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `network_protocol` when calling `system_network_interfaces_interface_id_network_protocol_configuration_get`")  # noqa: E501

        if self.api_client.client_side_validation and ('interface_id' in params and params['interface_id'] > 32):  # noqa: E501
            raise ValueError("Invalid value for parameter `interface_id` when calling `system_network_interfaces_interface_id_network_protocol_configuration_get`, must be a value less than or equal to `32`")  # noqa: E501
        if self.api_client.client_side_validation and ('interface_id' in params and params['interface_id'] < 0):  # noqa: E501
            raise ValueError("Invalid value for parameter `interface_id` when calling `system_network_interfaces_interface_id_network_protocol_configuration_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'interface_id' in params:
            path_params['interfaceId'] = params['interface_id']  # noqa: E501
        if 'network_protocol' in params:
            path_params['networkProtocol'] = params['network_protocol']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/network/interfaces/{interfaceId}/{networkProtocol}/configuration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IpConfiguration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_network_interfaces_interface_id_network_protocol_configuration_put(self, interface_id, network_protocol, ip_configuration, **kwargs):  # noqa: E501
        """Update the IP configuration of a network interface.  # noqa: E501

        Updates IPv4 or IPv6 configuration for the specified interface. This endpoint could be used to change the addressing mode between dynamic and static as well as setting the static IP address, prefix length, and gateway.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_interfaces_interface_id_network_protocol_configuration_put(interface_id, network_protocol, ip_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int interface_id: The unique identifier of the network interface assigned by the reader. (required)
        :param str network_protocol: The network protocol version of the configuration. (required)
        :param IpConfiguration ip_configuration: (required)
        :return: StatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_network_interfaces_interface_id_network_protocol_configuration_put_with_http_info(interface_id, network_protocol, ip_configuration, **kwargs)  # noqa: E501
        else:
            (data) = self.system_network_interfaces_interface_id_network_protocol_configuration_put_with_http_info(interface_id, network_protocol, ip_configuration, **kwargs)  # noqa: E501
            return data

    def system_network_interfaces_interface_id_network_protocol_configuration_put_with_http_info(self, interface_id, network_protocol, ip_configuration, **kwargs):  # noqa: E501
        """Update the IP configuration of a network interface.  # noqa: E501

        Updates IPv4 or IPv6 configuration for the specified interface. This endpoint could be used to change the addressing mode between dynamic and static as well as setting the static IP address, prefix length, and gateway.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_interfaces_interface_id_network_protocol_configuration_put_with_http_info(interface_id, network_protocol, ip_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int interface_id: The unique identifier of the network interface assigned by the reader. (required)
        :param str network_protocol: The network protocol version of the configuration. (required)
        :param IpConfiguration ip_configuration: (required)
        :return: StatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['interface_id', 'network_protocol', 'ip_configuration']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_network_interfaces_interface_id_network_protocol_configuration_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'interface_id' is set
        if self.api_client.client_side_validation and ('interface_id' not in params or
                                                       params['interface_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `interface_id` when calling `system_network_interfaces_interface_id_network_protocol_configuration_put`")  # noqa: E501
        # verify the required parameter 'network_protocol' is set
        if self.api_client.client_side_validation and ('network_protocol' not in params or
                                                       params['network_protocol'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `network_protocol` when calling `system_network_interfaces_interface_id_network_protocol_configuration_put`")  # noqa: E501
        # verify the required parameter 'ip_configuration' is set
        if self.api_client.client_side_validation and ('ip_configuration' not in params or
                                                       params['ip_configuration'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `ip_configuration` when calling `system_network_interfaces_interface_id_network_protocol_configuration_put`")  # noqa: E501

        if self.api_client.client_side_validation and ('interface_id' in params and params['interface_id'] > 32):  # noqa: E501
            raise ValueError("Invalid value for parameter `interface_id` when calling `system_network_interfaces_interface_id_network_protocol_configuration_put`, must be a value less than or equal to `32`")  # noqa: E501
        if self.api_client.client_side_validation and ('interface_id' in params and params['interface_id'] < 0):  # noqa: E501
            raise ValueError("Invalid value for parameter `interface_id` when calling `system_network_interfaces_interface_id_network_protocol_configuration_put`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'interface_id' in params:
            path_params['interfaceId'] = params['interface_id']  # noqa: E501
        if 'network_protocol' in params:
            path_params['networkProtocol'] = params['network_protocol']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ip_configuration' in params:
            body_params = params['ip_configuration']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/network/interfaces/{interfaceId}/{networkProtocol}/configuration', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_network_interfaces_interface_id_put(self, interface_id, network_interface_state, **kwargs):  # noqa: E501
        """Enable the specified network interface.  # noqa: E501

        Enable the specified network interface. There can be only one enabled and active interface at a time. A reboot is required for the change to take effect. Until the reader is rebooted, the previous enabled interface will stay active. Enabling one interface will automatically disable the other interface after the reader reboot.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_interfaces_interface_id_put(interface_id, network_interface_state, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int interface_id: The unique identifier of the network interface assigned by the reader. (required)
        :param NetworkInterfaceState network_interface_state: (required)
        :return: StatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_network_interfaces_interface_id_put_with_http_info(interface_id, network_interface_state, **kwargs)  # noqa: E501
        else:
            (data) = self.system_network_interfaces_interface_id_put_with_http_info(interface_id, network_interface_state, **kwargs)  # noqa: E501
            return data

    def system_network_interfaces_interface_id_put_with_http_info(self, interface_id, network_interface_state, **kwargs):  # noqa: E501
        """Enable the specified network interface.  # noqa: E501

        Enable the specified network interface. There can be only one enabled and active interface at a time. A reboot is required for the change to take effect. Until the reader is rebooted, the previous enabled interface will stay active. Enabling one interface will automatically disable the other interface after the reader reboot.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_interfaces_interface_id_put_with_http_info(interface_id, network_interface_state, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int interface_id: The unique identifier of the network interface assigned by the reader. (required)
        :param NetworkInterfaceState network_interface_state: (required)
        :return: StatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['interface_id', 'network_interface_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_network_interfaces_interface_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'interface_id' is set
        if self.api_client.client_side_validation and ('interface_id' not in params or
                                                       params['interface_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `interface_id` when calling `system_network_interfaces_interface_id_put`")  # noqa: E501
        # verify the required parameter 'network_interface_state' is set
        if self.api_client.client_side_validation and ('network_interface_state' not in params or
                                                       params['network_interface_state'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `network_interface_state` when calling `system_network_interfaces_interface_id_put`")  # noqa: E501

        if self.api_client.client_side_validation and ('interface_id' in params and params['interface_id'] > 32):  # noqa: E501
            raise ValueError("Invalid value for parameter `interface_id` when calling `system_network_interfaces_interface_id_put`, must be a value less than or equal to `32`")  # noqa: E501
        if self.api_client.client_side_validation and ('interface_id' in params and params['interface_id'] < 0):  # noqa: E501
            raise ValueError("Invalid value for parameter `interface_id` when calling `system_network_interfaces_interface_id_put`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'interface_id' in params:
            path_params['interfaceId'] = params['interface_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'network_interface_state' in params:
            body_params = params['network_interface_state']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/network/interfaces/{interfaceId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_network_interfaces_interface_id_wlan_access_points_get(self, interface_id, **kwargs):  # noqa: E501
        """Retrieve a list of the available access points using the specified network interface.  # noqa: E501

        Scan for access points using the specified network interface and return a list of available access points along with related information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_interfaces_interface_id_wlan_access_points_get(interface_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int interface_id: The unique identifier of the network interface assigned by the reader. (required)
        :return: list[NetworkWlanAccessPoint]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_network_interfaces_interface_id_wlan_access_points_get_with_http_info(interface_id, **kwargs)  # noqa: E501
        else:
            (data) = self.system_network_interfaces_interface_id_wlan_access_points_get_with_http_info(interface_id, **kwargs)  # noqa: E501
            return data

    def system_network_interfaces_interface_id_wlan_access_points_get_with_http_info(self, interface_id, **kwargs):  # noqa: E501
        """Retrieve a list of the available access points using the specified network interface.  # noqa: E501

        Scan for access points using the specified network interface and return a list of available access points along with related information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_interfaces_interface_id_wlan_access_points_get_with_http_info(interface_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int interface_id: The unique identifier of the network interface assigned by the reader. (required)
        :return: list[NetworkWlanAccessPoint]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['interface_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_network_interfaces_interface_id_wlan_access_points_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'interface_id' is set
        if self.api_client.client_side_validation and ('interface_id' not in params or
                                                       params['interface_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `interface_id` when calling `system_network_interfaces_interface_id_wlan_access_points_get`")  # noqa: E501

        if self.api_client.client_side_validation and ('interface_id' in params and params['interface_id'] > 32):  # noqa: E501
            raise ValueError("Invalid value for parameter `interface_id` when calling `system_network_interfaces_interface_id_wlan_access_points_get`, must be a value less than or equal to `32`")  # noqa: E501
        if self.api_client.client_side_validation and ('interface_id' in params and params['interface_id'] < 0):  # noqa: E501
            raise ValueError("Invalid value for parameter `interface_id` when calling `system_network_interfaces_interface_id_wlan_access_points_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'interface_id' in params:
            path_params['interfaceId'] = params['interface_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/network/interfaces/{interfaceId}/wlan/access-points', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NetworkWlanAccessPoint]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_network_interfaces_interface_id_wlan_connection_get(self, interface_id, **kwargs):  # noqa: E501
        """Retrieve the current WLAN connection status.  # noqa: E501

        Retrieves the current WLAN connection status.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_interfaces_interface_id_wlan_connection_get(interface_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int interface_id: The unique identifier of the network interface assigned by the reader. (required)
        :return: NetworkWlanConnectionStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_network_interfaces_interface_id_wlan_connection_get_with_http_info(interface_id, **kwargs)  # noqa: E501
        else:
            (data) = self.system_network_interfaces_interface_id_wlan_connection_get_with_http_info(interface_id, **kwargs)  # noqa: E501
            return data

    def system_network_interfaces_interface_id_wlan_connection_get_with_http_info(self, interface_id, **kwargs):  # noqa: E501
        """Retrieve the current WLAN connection status.  # noqa: E501

        Retrieves the current WLAN connection status.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_interfaces_interface_id_wlan_connection_get_with_http_info(interface_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int interface_id: The unique identifier of the network interface assigned by the reader. (required)
        :return: NetworkWlanConnectionStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['interface_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_network_interfaces_interface_id_wlan_connection_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'interface_id' is set
        if self.api_client.client_side_validation and ('interface_id' not in params or
                                                       params['interface_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `interface_id` when calling `system_network_interfaces_interface_id_wlan_connection_get`")  # noqa: E501

        if self.api_client.client_side_validation and ('interface_id' in params and params['interface_id'] > 32):  # noqa: E501
            raise ValueError("Invalid value for parameter `interface_id` when calling `system_network_interfaces_interface_id_wlan_connection_get`, must be a value less than or equal to `32`")  # noqa: E501
        if self.api_client.client_side_validation and ('interface_id' in params and params['interface_id'] < 0):  # noqa: E501
            raise ValueError("Invalid value for parameter `interface_id` when calling `system_network_interfaces_interface_id_wlan_connection_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'interface_id' in params:
            path_params['interfaceId'] = params['interface_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/network/interfaces/{interfaceId}/wlan/connection', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetworkWlanConnectionStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_network_interfaces_interface_id_wlan_connection_put(self, interface_id, network_wlan_connection, **kwargs):  # noqa: E501
        """Request a connection to the specified access point.  # noqa: E501

        Request a network connection to the specified access point using the specified SSID and a password.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_interfaces_interface_id_wlan_connection_put(interface_id, network_wlan_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int interface_id: The unique identifier of the network interface assigned by the reader. (required)
        :param NetworkWlanConnection network_wlan_connection: (required)
        :return: StatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_network_interfaces_interface_id_wlan_connection_put_with_http_info(interface_id, network_wlan_connection, **kwargs)  # noqa: E501
        else:
            (data) = self.system_network_interfaces_interface_id_wlan_connection_put_with_http_info(interface_id, network_wlan_connection, **kwargs)  # noqa: E501
            return data

    def system_network_interfaces_interface_id_wlan_connection_put_with_http_info(self, interface_id, network_wlan_connection, **kwargs):  # noqa: E501
        """Request a connection to the specified access point.  # noqa: E501

        Request a network connection to the specified access point using the specified SSID and a password.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_network_interfaces_interface_id_wlan_connection_put_with_http_info(interface_id, network_wlan_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int interface_id: The unique identifier of the network interface assigned by the reader. (required)
        :param NetworkWlanConnection network_wlan_connection: (required)
        :return: StatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['interface_id', 'network_wlan_connection']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_network_interfaces_interface_id_wlan_connection_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'interface_id' is set
        if self.api_client.client_side_validation and ('interface_id' not in params or
                                                       params['interface_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `interface_id` when calling `system_network_interfaces_interface_id_wlan_connection_put`")  # noqa: E501
        # verify the required parameter 'network_wlan_connection' is set
        if self.api_client.client_side_validation and ('network_wlan_connection' not in params or
                                                       params['network_wlan_connection'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `network_wlan_connection` when calling `system_network_interfaces_interface_id_wlan_connection_put`")  # noqa: E501

        if self.api_client.client_side_validation and ('interface_id' in params and params['interface_id'] > 32):  # noqa: E501
            raise ValueError("Invalid value for parameter `interface_id` when calling `system_network_interfaces_interface_id_wlan_connection_put`, must be a value less than or equal to `32`")  # noqa: E501
        if self.api_client.client_side_validation and ('interface_id' in params and params['interface_id'] < 0):  # noqa: E501
            raise ValueError("Invalid value for parameter `interface_id` when calling `system_network_interfaces_interface_id_wlan_connection_put`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'interface_id' in params:
            path_params['interfaceId'] = params['interface_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'network_wlan_connection' in params:
            body_params = params['network_wlan_connection']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/network/interfaces/{interfaceId}/wlan/connection', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_power_get(self, **kwargs):  # noqa: E501
        """Retrieve the current power configuration.  # noqa: E501

        Retrieves the current power configuration on the reader.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_power_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: PowerConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_power_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_power_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_power_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve the current power configuration.  # noqa: E501

        Retrieves the current power configuration on the reader.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_power_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: PowerConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_power_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/power', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerConfiguration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_power_put(self, power_source, **kwargs):  # noqa: E501
        """Configure the power source.  # noqa: E501

        Configures the power source to the specified value for the reader.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_power_put(power_source, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PowerSource power_source: The power source to be configured for the reader. (required)
        :return: StatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_power_put_with_http_info(power_source, **kwargs)  # noqa: E501
        else:
            (data) = self.system_power_put_with_http_info(power_source, **kwargs)  # noqa: E501
            return data

    def system_power_put_with_http_info(self, power_source, **kwargs):  # noqa: E501
        """Configure the power source.  # noqa: E501

        Configures the power source to the specified value for the reader.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_power_put_with_http_info(power_source, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PowerSource power_source: The power source to be configured for the reader. (required)
        :return: StatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['power_source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_power_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'power_source' is set
        if self.api_client.client_side_validation and ('power_source' not in params or
                                                       params['power_source'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `power_source` when calling `system_power_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'power_source' in params:
            body_params = params['power_source']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/power', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_reboot_post(self, **kwargs):  # noqa: E501
        """Reboot the system.  # noqa: E501

        A call to this endpoint will cause the system to reboot. Once this request is issued, subsequent calls to any endpoint will fail until the system is again available to service requests.  If an upgrade has been installed on the system, the reader will boot into the newly installed firmware image.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_reboot_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: StatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_reboot_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_reboot_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_reboot_post_with_http_info(self, **kwargs):  # noqa: E501
        """Reboot the system.  # noqa: E501

        A call to this endpoint will cause the system to reboot. Once this request is issued, subsequent calls to any endpoint will fail until the system is again available to service requests.  If an upgrade has been installed on the system, the reader will boot into the newly installed firmware image.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_reboot_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: StatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_reboot_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/reboot', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_region_get(self, **kwargs):  # noqa: E501
        """Retrieve region information.  # noqa: E501

        Retrieves the current operating region and a list of selectable regions for the reader.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_region_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: RegionInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_region_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_region_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_region_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve region information.  # noqa: E501

        Retrieves the current operating region and a list of selectable regions for the reader.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_region_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: RegionInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_region_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/region', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RegionInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_region_put(self, operating_region, **kwargs):  # noqa: E501
        """Configure the operating region.  # noqa: E501

        Configures the reader operating region to the specified region. This operation changes the reader RF settings. The operating region must match the country/region of operation to comply with local laws and regulations.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_region_put(operating_region, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OperatingRegion operating_region: The operating region to be configured for the reader. (required)
        :return: StatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_region_put_with_http_info(operating_region, **kwargs)  # noqa: E501
        else:
            (data) = self.system_region_put_with_http_info(operating_region, **kwargs)  # noqa: E501
            return data

    def system_region_put_with_http_info(self, operating_region, **kwargs):  # noqa: E501
        """Configure the operating region.  # noqa: E501

        Configures the reader operating region to the specified region. This operation changes the reader RF settings. The operating region must match the country/region of operation to comply with local laws and regulations.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_region_put_with_http_info(operating_region, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OperatingRegion operating_region: The operating region to be configured for the reader. (required)
        :return: StatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['operating_region']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_region_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'operating_region' is set
        if self.api_client.client_side_validation and ('operating_region' not in params or
                                                       params['operating_region'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `operating_region` when calling `system_region_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'operating_region' in params:
            body_params = params['operating_region']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/region', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_rfid_interface_get(self, **kwargs):  # noqa: E501
        """Retrieve the reader API.  # noqa: E501

        Retrieves the application programming interface (API) that is currently being used to control the reader RFID operations.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_rfid_interface_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: RfidInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_rfid_interface_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_rfid_interface_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_rfid_interface_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve the reader API.  # noqa: E501

        Retrieves the application programming interface (API) that is currently being used to control the reader RFID operations.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_rfid_interface_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: RfidInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_rfid_interface_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/rfid/interface', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RfidInterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_rfid_interface_put(self, rfid_interface, **kwargs):  # noqa: E501
        """Configure the reader API.  # noqa: E501

        Configures the application programming interface (API) that will be used to control the reader RFID operations.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_rfid_interface_put(rfid_interface, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RfidInterface rfid_interface: The API that will be used to control the reader RFID operations. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_rfid_interface_put_with_http_info(rfid_interface, **kwargs)  # noqa: E501
        else:
            (data) = self.system_rfid_interface_put_with_http_info(rfid_interface, **kwargs)  # noqa: E501
            return data

    def system_rfid_interface_put_with_http_info(self, rfid_interface, **kwargs):  # noqa: E501
        """Configure the reader API.  # noqa: E501

        Configures the application programming interface (API) that will be used to control the reader RFID operations.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_rfid_interface_put_with_http_info(rfid_interface, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RfidInterface rfid_interface: The API that will be used to control the reader RFID operations. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rfid_interface']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_rfid_interface_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rfid_interface' is set
        if self.api_client.client_side_validation and ('rfid_interface' not in params or
                                                       params['rfid_interface'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `rfid_interface` when calling `system_rfid_interface_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'rfid_interface' in params:
            body_params = params['rfid_interface']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/rfid/interface', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_rfid_llrp_get(self, **kwargs):  # noqa: E501
        """Retrieve LLRP status.  # noqa: E501

        Retrieves the current status of the LLRP interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_rfid_llrp_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: LlrpStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_rfid_llrp_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_rfid_llrp_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_rfid_llrp_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve LLRP status.  # noqa: E501

        Retrieves the current status of the LLRP interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_rfid_llrp_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: LlrpStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_rfid_llrp_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/rfid/llrp', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LlrpStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_time_get(self, **kwargs):  # noqa: E501
        """Retrieve information about system time and uptime.  # noqa: E501

        Retrieves information about system time and uptime. System time is in UTC and RFC-3339 compliant format. Uptime indicates how long the system has been running in seconds.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_time_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: TimeInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_time_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_time_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_time_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve information about system time and uptime.  # noqa: E501

        Retrieves information about system time and uptime. System time is in UTC and RFC-3339 compliant format. Uptime indicates how long the system has been running in seconds.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_time_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: TimeInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_time_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/time', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_time_ntp_get(self, **kwargs):  # noqa: E501
        """Retrieve the current state of the NTP service.  # noqa: E501

        Retrieves the current state of the NTP (Network Time Protocol) service on the reader. NTP service is responsible for synchronizing the system time on the reader with external NTP servers in order to keep the system time accurate and synchronized with other devices on the network.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_time_ntp_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_time_ntp_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_time_ntp_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_time_ntp_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve the current state of the NTP service.  # noqa: E501

        Retrieves the current state of the NTP (Network Time Protocol) service on the reader. NTP service is responsible for synchronizing the system time on the reader with external NTP servers in order to keep the system time accurate and synchronized with other devices on the network.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_time_ntp_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_time_ntp_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/time/ntp', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_time_ntp_put(self, ntp_configuration, **kwargs):  # noqa: E501
        """Configure the NTP service.  # noqa: E501

        Configures the NTP service on the reader.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_time_ntp_put(ntp_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NtpConfiguration ntp_configuration: The new NTP service configuration. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_time_ntp_put_with_http_info(ntp_configuration, **kwargs)  # noqa: E501
        else:
            (data) = self.system_time_ntp_put_with_http_info(ntp_configuration, **kwargs)  # noqa: E501
            return data

    def system_time_ntp_put_with_http_info(self, ntp_configuration, **kwargs):  # noqa: E501
        """Configure the NTP service.  # noqa: E501

        Configures the NTP service on the reader.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_time_ntp_put_with_http_info(ntp_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NtpConfiguration ntp_configuration: The new NTP service configuration. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ntp_configuration']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_time_ntp_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ntp_configuration' is set
        if self.api_client.client_side_validation and ('ntp_configuration' not in params or
                                                       params['ntp_configuration'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `ntp_configuration` when calling `system_time_ntp_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ntp_configuration' in params:
            body_params = params['ntp_configuration']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/time/ntp', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_time_ntp_servers_get(self, **kwargs):  # noqa: E501
        """Retrieve NTP servers.  # noqa: E501

        Retrieves NTP servers currently being used on the reader. These servers could be either statically configured or dynamically discovered via a DHCP server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_time_ntp_servers_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[NtpServer]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_time_ntp_servers_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_time_ntp_servers_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_time_ntp_servers_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve NTP servers.  # noqa: E501

        Retrieves NTP servers currently being used on the reader. These servers could be either statically configured or dynamically discovered via a DHCP server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_time_ntp_servers_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[NtpServer]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_time_ntp_servers_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/time/ntp/servers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NtpServer]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_time_ntp_servers_post(self, ntp_server, **kwargs):  # noqa: E501
        """Add a static NTP server.  # noqa: E501

        Adds a static NTP server to the reader. A NTP server can be specified by either hostname or IP address. The newly created NTP server object is returned upon a successful completion. The reader allows up to 6 static NTP servers.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_time_ntp_servers_post(ntp_server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NtpServer ntp_server: The static NTP server to add. (required)
        :return: NtpServer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_time_ntp_servers_post_with_http_info(ntp_server, **kwargs)  # noqa: E501
        else:
            (data) = self.system_time_ntp_servers_post_with_http_info(ntp_server, **kwargs)  # noqa: E501
            return data

    def system_time_ntp_servers_post_with_http_info(self, ntp_server, **kwargs):  # noqa: E501
        """Add a static NTP server.  # noqa: E501

        Adds a static NTP server to the reader. A NTP server can be specified by either hostname or IP address. The newly created NTP server object is returned upon a successful completion. The reader allows up to 6 static NTP servers.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_time_ntp_servers_post_with_http_info(ntp_server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NtpServer ntp_server: The static NTP server to add. (required)
        :return: NtpServer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ntp_server']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_time_ntp_servers_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ntp_server' is set
        if self.api_client.client_side_validation and ('ntp_server' not in params or
                                                       params['ntp_server'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `ntp_server` when calling `system_time_ntp_servers_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ntp_server' in params:
            body_params = params['ntp_server']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/time/ntp/servers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NtpServer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_time_ntp_servers_server_id_delete(self, server_id, **kwargs):  # noqa: E501
        """Remove a static NTP server.  # noqa: E501

        Removes a static NTP server from the reader. Note that dynamic NTP servers connot be removed. Both static and dynamic servers could be used together to improve the reliability and accuracy of the system time.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_time_ntp_servers_server_id_delete(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int server_id: The ID of the static NTP server to be removed. (required)
        :return: NtpServerInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_time_ntp_servers_server_id_delete_with_http_info(server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.system_time_ntp_servers_server_id_delete_with_http_info(server_id, **kwargs)  # noqa: E501
            return data

    def system_time_ntp_servers_server_id_delete_with_http_info(self, server_id, **kwargs):  # noqa: E501
        """Remove a static NTP server.  # noqa: E501

        Removes a static NTP server from the reader. Note that dynamic NTP servers connot be removed. Both static and dynamic servers could be used together to improve the reliability and accuracy of the system time.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_time_ntp_servers_server_id_delete_with_http_info(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int server_id: The ID of the static NTP server to be removed. (required)
        :return: NtpServerInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_time_ntp_servers_server_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if self.api_client.client_side_validation and ('server_id' not in params or
                                                       params['server_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `server_id` when calling `system_time_ntp_servers_server_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['serverId'] = params['server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/time/ntp/servers/{serverId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NtpServerInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_time_ntp_servers_server_id_get(self, server_id, **kwargs):  # noqa: E501
        """Retrieve details on a specific NTP server.  # noqa: E501

        Retrieves details on a specific NTP server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_time_ntp_servers_server_id_get(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int server_id: The unique identifier assigned to the NTP server by the reader. (required)
        :return: NtpServerInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_time_ntp_servers_server_id_get_with_http_info(server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.system_time_ntp_servers_server_id_get_with_http_info(server_id, **kwargs)  # noqa: E501
            return data

    def system_time_ntp_servers_server_id_get_with_http_info(self, server_id, **kwargs):  # noqa: E501
        """Retrieve details on a specific NTP server.  # noqa: E501

        Retrieves details on a specific NTP server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_time_ntp_servers_server_id_get_with_http_info(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int server_id: The unique identifier assigned to the NTP server by the reader. (required)
        :return: NtpServerInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_time_ntp_servers_server_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if self.api_client.client_side_validation and ('server_id' not in params or
                                                       params['server_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `server_id` when calling `system_time_ntp_servers_server_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['serverId'] = params['server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/time/ntp/servers/{serverId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NtpServerInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_time_put(self, system_time, **kwargs):  # noqa: E501
        """Update the system time.  # noqa: E501

        Updates the system time if NTP is disabled. If NTP is enabled, an error is returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_time_put(system_time, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SystemTime system_time: The new system time to be set in UTC and RFC-3339 format. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_time_put_with_http_info(system_time, **kwargs)  # noqa: E501
        else:
            (data) = self.system_time_put_with_http_info(system_time, **kwargs)  # noqa: E501
            return data

    def system_time_put_with_http_info(self, system_time, **kwargs):  # noqa: E501
        """Update the system time.  # noqa: E501

        Updates the system time if NTP is disabled. If NTP is enabled, an error is returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_time_put_with_http_info(system_time, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SystemTime system_time: The new system time to be set in UTC and RFC-3339 format. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_time']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_time_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'system_time' is set
        if self.api_client.client_side_validation and ('system_time' not in params or
                                                       params['system_time'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `system_time` when calling `system_time_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'system_time' in params:
            body_params = params['system_time']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/system/time', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def webhooks_event_get(self, **kwargs):  # noqa: E501
        """Get the event webhook configuration.  # noqa: E501

        Gets the event webhook configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.webhooks_event_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: EventWebhookConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.webhooks_event_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.webhooks_event_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def webhooks_event_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get the event webhook configuration.  # noqa: E501

        Gets the event webhook configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.webhooks_event_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: EventWebhookConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method webhooks_event_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/webhooks/event', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventWebhookConfiguration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def webhooks_event_put(self, event_webhook_configuration, **kwargs):  # noqa: E501
        """Set the event webhook configuration.  # noqa: E501

        Sets the event webhook configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.webhooks_event_put(event_webhook_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EventWebhookConfiguration event_webhook_configuration: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.webhooks_event_put_with_http_info(event_webhook_configuration, **kwargs)  # noqa: E501
        else:
            (data) = self.webhooks_event_put_with_http_info(event_webhook_configuration, **kwargs)  # noqa: E501
            return data

    def webhooks_event_put_with_http_info(self, event_webhook_configuration, **kwargs):  # noqa: E501
        """Set the event webhook configuration.  # noqa: E501

        Sets the event webhook configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.webhooks_event_put_with_http_info(event_webhook_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EventWebhookConfiguration event_webhook_configuration: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_webhook_configuration']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method webhooks_event_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_webhook_configuration' is set
        if self.api_client.client_side_validation and ('event_webhook_configuration' not in params or
                                                       params['event_webhook_configuration'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `event_webhook_configuration` when calling `webhooks_event_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'event_webhook_configuration' in params:
            body_params = params['event_webhook_configuration']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/webhooks/event', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
