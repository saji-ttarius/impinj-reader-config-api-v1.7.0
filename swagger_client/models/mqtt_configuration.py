# coding: utf-8

"""
    Impinj Reader Configuration REST API

    This API provides an interface for configuring RFID operations and reporting streams on Impinj Readers as well as updating Impinj Reader firmware and configuring system settings.  When retrieved from a reader, this OpenAPI Document is dynamically updated based on the capabilities of the reader. See the '/openapi.json' path.   # noqa: E501

    OpenAPI spec version: 1.7.0
    Contact: developer-feedback@impinj.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from swagger_client.configuration import Configuration


class MqttConfiguration(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'active': 'bool',
        'broker_hostname': 'str',
        'broker_port': 'int',
        'clean_session': 'bool',
        'client_id': 'str',
        'event_buffer_size': 'int',
        'event_per_second_limit': 'int',
        'event_pending_delivery_limit': 'int',
        'event_quality_of_service': 'int',
        'event_topic': 'str',
        'keep_alive_interval_seconds': 'int',
        'tls_enabled': 'bool',
        'username': 'str',
        'password': 'str',
        'will_topic': 'str',
        'will_message': 'str',
        'will_quality_of_service': 'int',
        'connect_message': 'str',
        'disconnect_message': 'str'
    }

    attribute_map = {
        'active': 'active',
        'broker_hostname': 'brokerHostname',
        'broker_port': 'brokerPort',
        'clean_session': 'cleanSession',
        'client_id': 'clientId',
        'event_buffer_size': 'eventBufferSize',
        'event_per_second_limit': 'eventPerSecondLimit',
        'event_pending_delivery_limit': 'eventPendingDeliveryLimit',
        'event_quality_of_service': 'eventQualityOfService',
        'event_topic': 'eventTopic',
        'keep_alive_interval_seconds': 'keepAliveIntervalSeconds',
        'tls_enabled': 'tlsEnabled',
        'username': 'username',
        'password': 'password',
        'will_topic': 'willTopic',
        'will_message': 'willMessage',
        'will_quality_of_service': 'willQualityOfService',
        'connect_message': 'connectMessage',
        'disconnect_message': 'disconnectMessage'
    }

    def __init__(self, active=False, broker_hostname=None, broker_port=None, clean_session=False, client_id=None, event_buffer_size=None, event_per_second_limit=None, event_pending_delivery_limit=None, event_quality_of_service=None, event_topic=None, keep_alive_interval_seconds=None, tls_enabled=False, username='', password='', will_topic='', will_message='connection lost', will_quality_of_service=None, connect_message='connected', disconnect_message='', _configuration=None):  # noqa: E501
        """MqttConfiguration - a model defined in Swagger"""  # noqa: E501
        if _configuration is None:
            _configuration = Configuration()
        self._configuration = _configuration

        self._active = None
        self._broker_hostname = None
        self._broker_port = None
        self._clean_session = None
        self._client_id = None
        self._event_buffer_size = None
        self._event_per_second_limit = None
        self._event_pending_delivery_limit = None
        self._event_quality_of_service = None
        self._event_topic = None
        self._keep_alive_interval_seconds = None
        self._tls_enabled = None
        self._username = None
        self._password = None
        self._will_topic = None
        self._will_message = None
        self._will_quality_of_service = None
        self._connect_message = None
        self._disconnect_message = None
        self.discriminator = None

        if active is not None:
            self.active = active
        self.broker_hostname = broker_hostname
        if broker_port is not None:
            self.broker_port = broker_port
        if clean_session is not None:
            self.clean_session = clean_session
        self.client_id = client_id
        if event_buffer_size is not None:
            self.event_buffer_size = event_buffer_size
        if event_per_second_limit is not None:
            self.event_per_second_limit = event_per_second_limit
        if event_pending_delivery_limit is not None:
            self.event_pending_delivery_limit = event_pending_delivery_limit
        if event_quality_of_service is not None:
            self.event_quality_of_service = event_quality_of_service
        self.event_topic = event_topic
        if keep_alive_interval_seconds is not None:
            self.keep_alive_interval_seconds = keep_alive_interval_seconds
        if tls_enabled is not None:
            self.tls_enabled = tls_enabled
        if username is not None:
            self.username = username
        if password is not None:
            self.password = password
        if will_topic is not None:
            self.will_topic = will_topic
        if will_message is not None:
            self.will_message = will_message
        if will_quality_of_service is not None:
            self.will_quality_of_service = will_quality_of_service
        if connect_message is not None:
            self.connect_message = connect_message
        if disconnect_message is not None:
            self.disconnect_message = disconnect_message

    @property
    def active(self):
        """Gets the active of this MqttConfiguration.  # noqa: E501

        Used to enable or disable MQTT output.  # noqa: E501

        :return: The active of this MqttConfiguration.  # noqa: E501
        :rtype: bool
        """
        return self._active

    @active.setter
    def active(self, active):
        """Sets the active of this MqttConfiguration.

        Used to enable or disable MQTT output.  # noqa: E501

        :param active: The active of this MqttConfiguration.  # noqa: E501
        :type: bool
        """

        self._active = active

    @property
    def broker_hostname(self):
        """Gets the broker_hostname of this MqttConfiguration.  # noqa: E501

        The hostname to use for connecting to the MQTT broker.  # noqa: E501

        :return: The broker_hostname of this MqttConfiguration.  # noqa: E501
        :rtype: str
        """
        return self._broker_hostname

    @broker_hostname.setter
    def broker_hostname(self, broker_hostname):
        """Sets the broker_hostname of this MqttConfiguration.

        The hostname to use for connecting to the MQTT broker.  # noqa: E501

        :param broker_hostname: The broker_hostname of this MqttConfiguration.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and broker_hostname is None:
            raise ValueError("Invalid value for `broker_hostname`, must not be `None`")  # noqa: E501
        if (self._configuration.client_side_validation and
                broker_hostname is not None and len(broker_hostname) > 253):
            raise ValueError("Invalid value for `broker_hostname`, length must be less than or equal to `253`")  # noqa: E501
        if (self._configuration.client_side_validation and
                broker_hostname is not None and len(broker_hostname) < 1):
            raise ValueError("Invalid value for `broker_hostname`, length must be greater than or equal to `1`")  # noqa: E501

        self._broker_hostname = broker_hostname

    @property
    def broker_port(self):
        """Gets the broker_port of this MqttConfiguration.  # noqa: E501

        The TCP port to use for connecting to the MQTT broker.  # noqa: E501

        :return: The broker_port of this MqttConfiguration.  # noqa: E501
        :rtype: int
        """
        return self._broker_port

    @broker_port.setter
    def broker_port(self, broker_port):
        """Sets the broker_port of this MqttConfiguration.

        The TCP port to use for connecting to the MQTT broker.  # noqa: E501

        :param broker_port: The broker_port of this MqttConfiguration.  # noqa: E501
        :type: int
        """
        if (self._configuration.client_side_validation and
                broker_port is not None and broker_port > 65535):  # noqa: E501
            raise ValueError("Invalid value for `broker_port`, must be a value less than or equal to `65535`")  # noqa: E501
        if (self._configuration.client_side_validation and
                broker_port is not None and broker_port < 1):  # noqa: E501
            raise ValueError("Invalid value for `broker_port`, must be a value greater than or equal to `1`")  # noqa: E501

        self._broker_port = broker_port

    @property
    def clean_session(self):
        """Gets the clean_session of this MqttConfiguration.  # noqa: E501

        This flag is used for determining the client's session type. When set to `true`, the broker will remove all information about this device when it disconnects. When set to `false`, the broker considers this device to be a durable client and preserves the appropriate state across client sessions.   # noqa: E501

        :return: The clean_session of this MqttConfiguration.  # noqa: E501
        :rtype: bool
        """
        return self._clean_session

    @clean_session.setter
    def clean_session(self, clean_session):
        """Sets the clean_session of this MqttConfiguration.

        This flag is used for determining the client's session type. When set to `true`, the broker will remove all information about this device when it disconnects. When set to `false`, the broker considers this device to be a durable client and preserves the appropriate state across client sessions.   # noqa: E501

        :param clean_session: The clean_session of this MqttConfiguration.  # noqa: E501
        :type: bool
        """

        self._clean_session = clean_session

    @property
    def client_id(self):
        """Gets the client_id of this MqttConfiguration.  # noqa: E501

        A string used to uniquely identify this device to the MQTT broker. This identifier is used for session management, allowing clients to be durable across several disconnects and reconnects.   # noqa: E501

        :return: The client_id of this MqttConfiguration.  # noqa: E501
        :rtype: str
        """
        return self._client_id

    @client_id.setter
    def client_id(self, client_id):
        """Sets the client_id of this MqttConfiguration.

        A string used to uniquely identify this device to the MQTT broker. This identifier is used for session management, allowing clients to be durable across several disconnects and reconnects.   # noqa: E501

        :param client_id: The client_id of this MqttConfiguration.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and client_id is None:
            raise ValueError("Invalid value for `client_id`, must not be `None`")  # noqa: E501
        if (self._configuration.client_side_validation and
                client_id is not None and len(client_id) > 23):
            raise ValueError("Invalid value for `client_id`, length must be less than or equal to `23`")  # noqa: E501
        if (self._configuration.client_side_validation and
                client_id is not None and len(client_id) < 1):
            raise ValueError("Invalid value for `client_id`, length must be greater than or equal to `1`")  # noqa: E501
        if (self._configuration.client_side_validation and
                client_id is not None and not re.search(r'^[a-zA-Z0-9]+$', client_id)):  # noqa: E501
            raise ValueError(r"Invalid value for `client_id`, must be a follow pattern or equal to `/^[a-zA-Z0-9]+$/`")  # noqa: E501

        self._client_id = client_id

    @property
    def event_buffer_size(self):
        """Gets the event_buffer_size of this MqttConfiguration.  # noqa: E501

        Number of events that can be stored on the reader waiting for delivery to the MQTT broker.   # noqa: E501

        :return: The event_buffer_size of this MqttConfiguration.  # noqa: E501
        :rtype: int
        """
        return self._event_buffer_size

    @event_buffer_size.setter
    def event_buffer_size(self, event_buffer_size):
        """Sets the event_buffer_size of this MqttConfiguration.

        Number of events that can be stored on the reader waiting for delivery to the MQTT broker.   # noqa: E501

        :param event_buffer_size: The event_buffer_size of this MqttConfiguration.  # noqa: E501
        :type: int
        """
        if (self._configuration.client_side_validation and
                event_buffer_size is not None and event_buffer_size > 300000):  # noqa: E501
            raise ValueError("Invalid value for `event_buffer_size`, must be a value less than or equal to `300000`")  # noqa: E501
        if (self._configuration.client_side_validation and
                event_buffer_size is not None and event_buffer_size < 1000):  # noqa: E501
            raise ValueError("Invalid value for `event_buffer_size`, must be a value greater than or equal to `1000`")  # noqa: E501

        self._event_buffer_size = event_buffer_size

    @property
    def event_per_second_limit(self):
        """Gets the event_per_second_limit of this MqttConfiguration.  # noqa: E501

        Maximum number of events that may be delivered per second.  This setting can be used to throttle the delivery of events during peak transmission times such as recovery after a network outage.  Care should be taken to not set this value lower than the normal event generation rate of the reader or the queue will fill up and events will be purged.  A value of Zero (0) means that no eventsPerSecondLimit is applied.   # noqa: E501

        :return: The event_per_second_limit of this MqttConfiguration.  # noqa: E501
        :rtype: int
        """
        return self._event_per_second_limit

    @event_per_second_limit.setter
    def event_per_second_limit(self, event_per_second_limit):
        """Sets the event_per_second_limit of this MqttConfiguration.

        Maximum number of events that may be delivered per second.  This setting can be used to throttle the delivery of events during peak transmission times such as recovery after a network outage.  Care should be taken to not set this value lower than the normal event generation rate of the reader or the queue will fill up and events will be purged.  A value of Zero (0) means that no eventsPerSecondLimit is applied.   # noqa: E501

        :param event_per_second_limit: The event_per_second_limit of this MqttConfiguration.  # noqa: E501
        :type: int
        """
        if (self._configuration.client_side_validation and
                event_per_second_limit is not None and event_per_second_limit > 100000):  # noqa: E501
            raise ValueError("Invalid value for `event_per_second_limit`, must be a value less than or equal to `100000`")  # noqa: E501
        if (self._configuration.client_side_validation and
                event_per_second_limit is not None and event_per_second_limit < 0):  # noqa: E501
            raise ValueError("Invalid value for `event_per_second_limit`, must be a value greater than or equal to `0`")  # noqa: E501

        self._event_per_second_limit = event_per_second_limit

    @property
    def event_pending_delivery_limit(self):
        """Gets the event_pending_delivery_limit of this MqttConfiguration.  # noqa: E501

        Maximum number of events concurrently processed by the mqtt delivery layer. When eventQualityOfService is greater than Zero (0) this will limit the rate of delivery to the MQTT broker.   # noqa: E501

        :return: The event_pending_delivery_limit of this MqttConfiguration.  # noqa: E501
        :rtype: int
        """
        return self._event_pending_delivery_limit

    @event_pending_delivery_limit.setter
    def event_pending_delivery_limit(self, event_pending_delivery_limit):
        """Sets the event_pending_delivery_limit of this MqttConfiguration.

        Maximum number of events concurrently processed by the mqtt delivery layer. When eventQualityOfService is greater than Zero (0) this will limit the rate of delivery to the MQTT broker.   # noqa: E501

        :param event_pending_delivery_limit: The event_pending_delivery_limit of this MqttConfiguration.  # noqa: E501
        :type: int
        """
        if (self._configuration.client_side_validation and
                event_pending_delivery_limit is not None and event_pending_delivery_limit > 10000):  # noqa: E501
            raise ValueError("Invalid value for `event_pending_delivery_limit`, must be a value less than or equal to `10000`")  # noqa: E501
        if (self._configuration.client_side_validation and
                event_pending_delivery_limit is not None and event_pending_delivery_limit < 10):  # noqa: E501
            raise ValueError("Invalid value for `event_pending_delivery_limit`, must be a value greater than or equal to `10`")  # noqa: E501

        self._event_pending_delivery_limit = event_pending_delivery_limit

    @property
    def event_quality_of_service(self):
        """Gets the event_quality_of_service of this MqttConfiguration.  # noqa: E501

        The QoS level of the MQTT connection. The different levels can be described as follows, according to the MQTT specification:  #### QoS 0: At most once delivery  The message is delivered according to the capabilities of the underlying network. No response is sent by the receiver and no retry is performed by the sender. The message arrives at the receiver either once or not at all.  #### QoS 1: At least once delivery  This quality of service ensures that the message arrives at the receiver at least once, possibly multiple times.  #### QoS 2: Exactly once delivery  This is the highest quality of service, for use when neither loss nor duplication of messages are acceptable. There is an increased overhead associated with this quality of service.   # noqa: E501

        :return: The event_quality_of_service of this MqttConfiguration.  # noqa: E501
        :rtype: int
        """
        return self._event_quality_of_service

    @event_quality_of_service.setter
    def event_quality_of_service(self, event_quality_of_service):
        """Sets the event_quality_of_service of this MqttConfiguration.

        The QoS level of the MQTT connection. The different levels can be described as follows, according to the MQTT specification:  #### QoS 0: At most once delivery  The message is delivered according to the capabilities of the underlying network. No response is sent by the receiver and no retry is performed by the sender. The message arrives at the receiver either once or not at all.  #### QoS 1: At least once delivery  This quality of service ensures that the message arrives at the receiver at least once, possibly multiple times.  #### QoS 2: Exactly once delivery  This is the highest quality of service, for use when neither loss nor duplication of messages are acceptable. There is an increased overhead associated with this quality of service.   # noqa: E501

        :param event_quality_of_service: The event_quality_of_service of this MqttConfiguration.  # noqa: E501
        :type: int
        """
        if (self._configuration.client_side_validation and
                event_quality_of_service is not None and event_quality_of_service > 2):  # noqa: E501
            raise ValueError("Invalid value for `event_quality_of_service`, must be a value less than or equal to `2`")  # noqa: E501
        if (self._configuration.client_side_validation and
                event_quality_of_service is not None and event_quality_of_service < 0):  # noqa: E501
            raise ValueError("Invalid value for `event_quality_of_service`, must be a value greater than or equal to `0`")  # noqa: E501

        self._event_quality_of_service = event_quality_of_service

    @property
    def event_topic(self):
        """Gets the event_topic of this MqttConfiguration.  # noqa: E501

        The base topic where the device will publish events.  # noqa: E501

        :return: The event_topic of this MqttConfiguration.  # noqa: E501
        :rtype: str
        """
        return self._event_topic

    @event_topic.setter
    def event_topic(self, event_topic):
        """Sets the event_topic of this MqttConfiguration.

        The base topic where the device will publish events.  # noqa: E501

        :param event_topic: The event_topic of this MqttConfiguration.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and event_topic is None:
            raise ValueError("Invalid value for `event_topic`, must not be `None`")  # noqa: E501
        if (self._configuration.client_side_validation and
                event_topic is not None and len(event_topic) > 200):
            raise ValueError("Invalid value for `event_topic`, length must be less than or equal to `200`")  # noqa: E501
        if (self._configuration.client_side_validation and
                event_topic is not None and len(event_topic) < 1):
            raise ValueError("Invalid value for `event_topic`, length must be greater than or equal to `1`")  # noqa: E501
        if (self._configuration.client_side_validation and
                event_topic is not None and not re.search(r'^[^#+]*$', event_topic)):  # noqa: E501
            raise ValueError(r"Invalid value for `event_topic`, must be a follow pattern or equal to `/^[^#+]*$/`")  # noqa: E501

        self._event_topic = event_topic

    @property
    def keep_alive_interval_seconds(self):
        """Gets the keep_alive_interval_seconds of this MqttConfiguration.  # noqa: E501

        Specifies how often the device should check-in with the broker by sending a control packet. From the MQTT specification:  > If the Keep Alive value is non-zero and the Server does not receive a Control Packet > from the Client within one and a half times the Keep Alive time period, it MUST > disconnect the Network Connection to the Client as if the network had failed.   # noqa: E501

        :return: The keep_alive_interval_seconds of this MqttConfiguration.  # noqa: E501
        :rtype: int
        """
        return self._keep_alive_interval_seconds

    @keep_alive_interval_seconds.setter
    def keep_alive_interval_seconds(self, keep_alive_interval_seconds):
        """Sets the keep_alive_interval_seconds of this MqttConfiguration.

        Specifies how often the device should check-in with the broker by sending a control packet. From the MQTT specification:  > If the Keep Alive value is non-zero and the Server does not receive a Control Packet > from the Client within one and a half times the Keep Alive time period, it MUST > disconnect the Network Connection to the Client as if the network had failed.   # noqa: E501

        :param keep_alive_interval_seconds: The keep_alive_interval_seconds of this MqttConfiguration.  # noqa: E501
        :type: int
        """
        if (self._configuration.client_side_validation and
                keep_alive_interval_seconds is not None and keep_alive_interval_seconds > 65535):  # noqa: E501
            raise ValueError("Invalid value for `keep_alive_interval_seconds`, must be a value less than or equal to `65535`")  # noqa: E501
        if (self._configuration.client_side_validation and
                keep_alive_interval_seconds is not None and keep_alive_interval_seconds < 0):  # noqa: E501
            raise ValueError("Invalid value for `keep_alive_interval_seconds`, must be a value greater than or equal to `0`")  # noqa: E501

        self._keep_alive_interval_seconds = keep_alive_interval_seconds

    @property
    def tls_enabled(self):
        """Gets the tls_enabled of this MqttConfiguration.  # noqa: E501

        Specifies whether MQTT client should initiate secure connections to the broker. When set to `true`, CA certificate(s) that signed the broker's server certificate must be installed on the reader to allow for server authentication unless the server certificate could be traced back to a well-known root CA pre-installed on the reader.   # noqa: E501

        :return: The tls_enabled of this MqttConfiguration.  # noqa: E501
        :rtype: bool
        """
        return self._tls_enabled

    @tls_enabled.setter
    def tls_enabled(self, tls_enabled):
        """Sets the tls_enabled of this MqttConfiguration.

        Specifies whether MQTT client should initiate secure connections to the broker. When set to `true`, CA certificate(s) that signed the broker's server certificate must be installed on the reader to allow for server authentication unless the server certificate could be traced back to a well-known root CA pre-installed on the reader.   # noqa: E501

        :param tls_enabled: The tls_enabled of this MqttConfiguration.  # noqa: E501
        :type: bool
        """

        self._tls_enabled = tls_enabled

    @property
    def username(self):
        """Gets the username of this MqttConfiguration.  # noqa: E501

        The username to use when authenticating with the broker.  # noqa: E501

        :return: The username of this MqttConfiguration.  # noqa: E501
        :rtype: str
        """
        return self._username

    @username.setter
    def username(self, username):
        """Sets the username of this MqttConfiguration.

        The username to use when authenticating with the broker.  # noqa: E501

        :param username: The username of this MqttConfiguration.  # noqa: E501
        :type: str
        """
        if (self._configuration.client_side_validation and
                username is not None and len(username) > 200):
            raise ValueError("Invalid value for `username`, length must be less than or equal to `200`")  # noqa: E501
        if (self._configuration.client_side_validation and
                username is not None and len(username) < 0):
            raise ValueError("Invalid value for `username`, length must be greater than or equal to `0`")  # noqa: E501

        self._username = username

    @property
    def password(self):
        """Gets the password of this MqttConfiguration.  # noqa: E501

        The password to use when authenticating with the broker.  # noqa: E501

        :return: The password of this MqttConfiguration.  # noqa: E501
        :rtype: str
        """
        return self._password

    @password.setter
    def password(self, password):
        """Sets the password of this MqttConfiguration.

        The password to use when authenticating with the broker.  # noqa: E501

        :param password: The password of this MqttConfiguration.  # noqa: E501
        :type: str
        """
        if (self._configuration.client_side_validation and
                password is not None and len(password) > 200):
            raise ValueError("Invalid value for `password`, length must be less than or equal to `200`")  # noqa: E501
        if (self._configuration.client_side_validation and
                password is not None and len(password) < 0):
            raise ValueError("Invalid value for `password`, length must be greater than or equal to `0`")  # noqa: E501

        self._password = password

    @property
    def will_topic(self):
        """Gets the will_topic of this MqttConfiguration.  # noqa: E501

        The topic to which status messages are sent. If this parameter is unset or an empty string, no status messages will be sent. See `willMessage`, `connectMessage`, and `disconnectMessage` (the status messages).   # noqa: E501

        :return: The will_topic of this MqttConfiguration.  # noqa: E501
        :rtype: str
        """
        return self._will_topic

    @will_topic.setter
    def will_topic(self, will_topic):
        """Sets the will_topic of this MqttConfiguration.

        The topic to which status messages are sent. If this parameter is unset or an empty string, no status messages will be sent. See `willMessage`, `connectMessage`, and `disconnectMessage` (the status messages).   # noqa: E501

        :param will_topic: The will_topic of this MqttConfiguration.  # noqa: E501
        :type: str
        """
        if (self._configuration.client_side_validation and
                will_topic is not None and len(will_topic) > 200):
            raise ValueError("Invalid value for `will_topic`, length must be less than or equal to `200`")  # noqa: E501
        if (self._configuration.client_side_validation and
                will_topic is not None and len(will_topic) < 0):
            raise ValueError("Invalid value for `will_topic`, length must be greater than or equal to `0`")  # noqa: E501
        if (self._configuration.client_side_validation and
                will_topic is not None and not re.search(r'^[^#+]*$', will_topic)):  # noqa: E501
            raise ValueError(r"Invalid value for `will_topic`, must be a follow pattern or equal to `/^[^#+]*$/`")  # noqa: E501

        self._will_topic = will_topic

    @property
    def will_message(self):
        """Gets the will_message of this MqttConfiguration.  # noqa: E501

        The status message to be sent by the broker to the `willTopic` if the reader disconnects ungracefully. This normally means something unusual has happened such a power outage, network error, or firmware error.   # noqa: E501

        :return: The will_message of this MqttConfiguration.  # noqa: E501
        :rtype: str
        """
        return self._will_message

    @will_message.setter
    def will_message(self, will_message):
        """Sets the will_message of this MqttConfiguration.

        The status message to be sent by the broker to the `willTopic` if the reader disconnects ungracefully. This normally means something unusual has happened such a power outage, network error, or firmware error.   # noqa: E501

        :param will_message: The will_message of this MqttConfiguration.  # noqa: E501
        :type: str
        """
        if (self._configuration.client_side_validation and
                will_message is not None and len(will_message) > 500):
            raise ValueError("Invalid value for `will_message`, length must be less than or equal to `500`")  # noqa: E501
        if (self._configuration.client_side_validation and
                will_message is not None and len(will_message) < 0):
            raise ValueError("Invalid value for `will_message`, length must be greater than or equal to `0`")  # noqa: E501

        self._will_message = will_message

    @property
    def will_quality_of_service(self):
        """Gets the will_quality_of_service of this MqttConfiguration.  # noqa: E501

        The Quality of Service (QoS) of status messages. See `willMessage`, `connectMessage`, and `disconnectMessage` (the status messages). See `eventQualityOfService` for details on how the different quality of service levels affect message transmission.   # noqa: E501

        :return: The will_quality_of_service of this MqttConfiguration.  # noqa: E501
        :rtype: int
        """
        return self._will_quality_of_service

    @will_quality_of_service.setter
    def will_quality_of_service(self, will_quality_of_service):
        """Sets the will_quality_of_service of this MqttConfiguration.

        The Quality of Service (QoS) of status messages. See `willMessage`, `connectMessage`, and `disconnectMessage` (the status messages). See `eventQualityOfService` for details on how the different quality of service levels affect message transmission.   # noqa: E501

        :param will_quality_of_service: The will_quality_of_service of this MqttConfiguration.  # noqa: E501
        :type: int
        """
        if (self._configuration.client_side_validation and
                will_quality_of_service is not None and will_quality_of_service > 2):  # noqa: E501
            raise ValueError("Invalid value for `will_quality_of_service`, must be a value less than or equal to `2`")  # noqa: E501
        if (self._configuration.client_side_validation and
                will_quality_of_service is not None and will_quality_of_service < 0):  # noqa: E501
            raise ValueError("Invalid value for `will_quality_of_service`, must be a value greater than or equal to `0`")  # noqa: E501

        self._will_quality_of_service = will_quality_of_service

    @property
    def connect_message(self):
        """Gets the connect_message of this MqttConfiguration.  # noqa: E501

        The status message to send to the `willTopic` when the reader connects or reconnects to the broker.   # noqa: E501

        :return: The connect_message of this MqttConfiguration.  # noqa: E501
        :rtype: str
        """
        return self._connect_message

    @connect_message.setter
    def connect_message(self, connect_message):
        """Sets the connect_message of this MqttConfiguration.

        The status message to send to the `willTopic` when the reader connects or reconnects to the broker.   # noqa: E501

        :param connect_message: The connect_message of this MqttConfiguration.  # noqa: E501
        :type: str
        """
        if (self._configuration.client_side_validation and
                connect_message is not None and len(connect_message) > 500):
            raise ValueError("Invalid value for `connect_message`, length must be less than or equal to `500`")  # noqa: E501
        if (self._configuration.client_side_validation and
                connect_message is not None and len(connect_message) < 0):
            raise ValueError("Invalid value for `connect_message`, length must be greater than or equal to `0`")  # noqa: E501

        self._connect_message = connect_message

    @property
    def disconnect_message(self):
        """Gets the disconnect_message of this MqttConfiguration.  # noqa: E501

        The status message to send to the `willTopic` when the reader disconnects from the broker gracefully. A graceful disconnect includes disabling the IoT Interface, disabling MQTT output, or rebooting the reader.   # noqa: E501

        :return: The disconnect_message of this MqttConfiguration.  # noqa: E501
        :rtype: str
        """
        return self._disconnect_message

    @disconnect_message.setter
    def disconnect_message(self, disconnect_message):
        """Sets the disconnect_message of this MqttConfiguration.

        The status message to send to the `willTopic` when the reader disconnects from the broker gracefully. A graceful disconnect includes disabling the IoT Interface, disabling MQTT output, or rebooting the reader.   # noqa: E501

        :param disconnect_message: The disconnect_message of this MqttConfiguration.  # noqa: E501
        :type: str
        """
        if (self._configuration.client_side_validation and
                disconnect_message is not None and len(disconnect_message) > 500):
            raise ValueError("Invalid value for `disconnect_message`, length must be less than or equal to `500`")  # noqa: E501
        if (self._configuration.client_side_validation and
                disconnect_message is not None and len(disconnect_message) < 0):
            raise ValueError("Invalid value for `disconnect_message`, length must be greater than or equal to `0`")  # noqa: E501

        self._disconnect_message = disconnect_message

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(MqttConfiguration, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, MqttConfiguration):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, MqttConfiguration):
            return True

        return self.to_dict() != other.to_dict()
